\chapter{Программный интерфейс взаимодействия сокетов Беркли}

В стандартах TCP/IP не даны подробные сведения о том,  каким образом прикладное ПО должно взаимодействовать с ПО протоколов TCP/IP; в них описаны только необходимые функциональные средства,  а возможность определять конкретные требования к реализации API-интерфейса предоставлена системным проектировщикам.

Интерфейс между TCP/IP и приложениями,  в которых используются эти протоколы,  определены неформально,  в виде рекомендаций,  а не требований.

Применение неформальной спецификации имеет свои преимущества и недостатки.

К преимуществам относятся гибкость и широкая применяемость,  что позволяет проектировщикам реализовывать протоколы TCP/IP для любых операционных систем. Также проектировщики имеют возможность использовать органихацию интерфейса,  наиболее подходящую для операционной системы (например процедурную или основанную на передаче сообщений).

Недостатком неформальной спецификации является то,  что ее применение может привести к появлению различий в отдельных деталях реализации интерфейса для каждой ОС. 

На практике существует лишь небольшое количество API-интерфейсов, позволяющих использовать протоколы TCP/IP во всех приложениях. На данный момент получили наиболее широкое распространение 3 интерфейса: 
\begin{itemize}
\item сокеты Беркли (сокеты,  интерфейс сокетов),  разработанный в ун-те Беркли; 
\item Windows Sockets, разработанный в компании Microsoft;
\item TLI (Transport Layer Interface), разработанный AT\&T для системы Unix версии System V.
\end{itemize}

\section{Функциональные средства интерфейса}

\begin{itemize}
\item распределение локальных ресурсов для связи;
\item задание локальной и удаленной оконечных точек связи;
\item инициирование соединения (клиент);
\item передача дейтаграммы (клиент);
\item ожидание входящего запроса на установление соединения (сервер);
\item передача или прием данных;
\item определение момента поступления данных;
\item выработка срочных данных;
\item обработка входящих срочных данных;
\item корректное завершение соединения;
\item обработка запроса на завершение соединения от удаленного участника соединения;
\item аварийное прекращение связи;
\item устранение последствий аварийных ситуаций или аварийного прекращения связи;
\item освобождение локальных ресурсов после завершения связи.
\end{itemize}


\section{Сокеты Berkeley}

В начале 80-х годов агенство ARPA финансировало работу группы разработчиков Калифорнийского университета в г.Беркли,  которые должны были создать программное обеспечение транспортных протоколов TCP/IP для системы Unix и предоставить разработанный ПО в распоряжение представителей других организаций.

Они решили применять уже существующие системные вызовы и вводить новые только для поддержки функций TCP/IP,  которые нельзя легко включить в существующий набор функций. Результаты этого проекта получили широкую известность под названием “API-интерфейса сокетов” или просто интерфейса сокетов,  а разработанная система стала называться Berkeley UNIX или просто UNIX . Протокол ТСР впервые появился в выпуске 4.1 дистрибутива BSD (Berkeley Software Distribution).

В дальнейшем система Berkeley UNIX была адаптированна для своих целей многими поставщиками компьютеров: Sun Microsystems,  Tektronix,  Digital Equipment Corporation. Таким образом интерфейс получил настолько широкое распространение,  что стал считаться стандартом де-факто. Корпорация Micosoft внесла свой вклад в распространение интерфейса,  разработав версию сокетов для своей операционной системы.

Проектировщики из BSD предусмотрели возможность применения различных семейств протоколов связи,  далеко выходящую за рамки протоколов TCP/IP. 
Среди них протоколы TCP/IP представлены единственным семейством PF\_INET. Они также предусмотрели,  
чтобы в приложениях необходимые операции связи определялись путем указания на тип требуемой службы,  
а не выбора имени протокола. Поэтому вместо указания на то,  что ему требуется соединение TCP,
приложение запрашивает службу типа потоковой передачи семейства протоколов Интернет.

API-интерфейс сокетов предоставляет обобщенные функции,  которые поддерживают сетевую связь с помощью многих возможных протоколов. В вызовах функций сокетов все протоколы TCP/IP упоминаются как одно семейство протоколов. Эти вызовы позволяют программистам указывать тип требуемой службы,  а не имя конкретного протокола.

\section{Основные понятия}

Под сетевым адресом понимается видимый в пределах сети идентификатор, используемый для обозначения оконечных точек сети. Адреса есть у определенных оконечных точек хостов, могут они быть и у хостов в целом \cite{intuit-galatenko-01}.

Данные о хостах как узлах сети хранятся в сетевой базе, допускающей и последовательный, и случайный доступ с возможностью поиска по именам и адресам хостов. 

Процесс присвоения сетевого адреса оконечной точке называется связыванием, или привязкой, а обратное действие - освобождением, или отменой привязки. 

Обычно оконечной точкой служит аппаратный сетевой интерфейс, посредством которого данные передаются и принимаются, однако с таким интерфейсом, как шлейфовый (loopback), никакой аппаратуры не ассоциировано. 

Поддерживается база данных маршрутизации, используемая при выборе сетевого интерфейса для передачи порции данных (сетевого пакета). 

Данные передаются по сети в виде последовательности октетов (восьмибитных беззнаковых величин). Если некоторый элемент данных (например, адрес или номер порта) состоит более чем из восьми бит, для его передачи и хранения требуется несколько октетов. Сетевым называется порядок октетов (байт), при котором первый (с наименьшим адресом) октет содержит старшие (наиболее значимые) биты. 

Последовательности октетов - неудобный объект обработки на хостах, где предпочтительнее аппаратно поддерживаемые типы, в особенности целочисленные. Значения этих типов обычно хранятся с другим порядком байт, называемым хостовым, поэтому вполне возможно, что старшего бита не окажется в первом байте и вообще будет использоваться некое неочевидное распределение бит по байтам. 

Для преобразования значений типов {\tt uint16\_t} и {\tt uint32\_t} из хостового порядка байт в сетевой служат функции {\tt htons} и {\tt htonl}, функции {\tt ntohs} и {\tt ntohl} осуществляют обратную операцию. 

При взаимодействии процессов оконечными точками служат сокеты, они трактуются стандартом POSIX-2001 как отдельный тип файлов.

Под адресом сокета как (удаленной) оконечной точки понимается структура, включающая идентификатор адресного семейства и адресную информацию, специфичную для данного семейства. Последняя может состоять из нескольких компонентов, в том числе сетевого адреса хоста и идентификатора конкретной оконечной точки. 

Приложение,  которому требуется произвести операции ввода/вывода с файлом, вызывает функцию {\tt open},  чтобы создать дескриптор файла,  применяемый для доступа к файлу. 

Для процесса существует отдельная таблица дескрипторов,  которая используется для хранения указателей на внутренние струкуры данных для файлов, открытых процессом.

В API-интерфейсе сокетов реализовано новое абстрактное понятие для сетевой связи –-- {\bf сокет}. Как и файл,  сокет обозначается целым числом,  называемым дескриптором сокета. Операционная система размещает дескрипторы сокетов в той же таблице дескрипторов,  что и дескрипторы файлов. Поэтому в приложении не может присутствовать и дескриптор файлов и дескриптор сокетов с одним и тем же значением.

В ОС предусмотрена отдельная системная функция {\tt socket},  вызываемая приложением для создания 
сокета (функция {\tt open} используется только для создания файлов). Общий замысел,  
который лёг в основу разработки интерфейса сокетов,  состоял в том,  чтобы для создания любого сокета
было достаточно одного системного вызова. Для указания точных сведений о назначении сокета
нужно выполнить еще несколько системных вызовов.

Сам сокет является универсальным средством ввода/вывода и может применяться для любой связи. Поэтому приложение должно указывать, как он будет использоваться. В частности необходимо указать номера портов протокола и адреса локального и удаленного компьютеров. 

Для обозначения типа адреса используется структура:

\begin{lstlisting}[language=C]
struct sockaddr{
	u_char sa_len;
	u_short sa_family;
	char sa_data[14];
}
\end{lstlisting}
\begin{itemize}
\item sa\_len -- общая длина (только с BSD 4.4 );
\item sa\_family -- тип адреса;
\item sa\_data[14] -- значение адреса.
\end{itemize}

Для обеспечения свободы выбора представлений используемых адресов,  в каждом семействе протоколов спецификация сокета определяет семейство адресов для каждого типа адреса. Во всех протоколах TCP/IP применяется единственное представление адреса,  а семейство адресов обозначается как AF\_INET.

Адресное семейство соответствует конкретной среде взаимодействия. Стандарт POSIX-2001 определяет три таких семейства:
\begin{itemize}
	\item AF\_UNIX -- Адресное семейство UNIX поддерживает межпроцессное взаимодействие в пределах одной системы. Формально это можно считать вырожденным случаем сетевого взаимодействия. Описания, специфичные для данного семейства, содержатся в заголовочном файле <sys/un.h>. 
	\item AF\_INET -- Адресное семейство, поддерживающее взаимодействие по протоколам IPv4. 
		Специфичные для него описания располагаются в заголовочном файле <netinet/in.h>. 
	\item AF\_INET6 -- Взаимодействие по протоколам IPv6 (необязательная возможность). 
		За счет поддержки адресов IPv6, отображенных на IPv4, обеспечивается совместимость с приложениями, 
		использующими IPv4. Применяемые эти адресным семейством описания распределены по заголовочным 
		файлам <netinet/in.h>, <arpa/inet.h> и <netdb.h>. 
\end{itemize}

Между PF\_INET и AF\_INET часто возникает путаница,  в основном из-за того,  что эти константы имеют общее числовое значение и могут быть заменены между собой,  хотя это неправильно.

Для приложений,  которые используют исключительно TCP/IP,  для определения типа адреса достаточно использовать структуру:
\begin{lstlisting}[language=C]
struct sockaddr{
	u_char sin_len;
	u_short sin_family;
	u_short sin_port;
	struct in_addr sin_addr;
	char sin_zero[8];
}
\end{lstlisting}
\begin{itemize}
	\item sin\_len -- общая длина (только с BSD 4.4 );
	\item sin\_family -- тип адреса;
	\item sin\_port -- номер порта протокола;
	\item sin\_addr -- IP-адрес (иногда = u\_long);
	\item sin\_zero[8] -- не используется (=0).
\end{itemize}

В пределах каждого адресного семейства могут существовать сокеты нескольких типов. В стандарте POSIX-2001 их четыре:
\begin{itemize}
	\item SOCK\_STREAM -- Сокеты данного типа поддерживают надежные, упорядоченные, полнодуплексные потоки октетов в режиме с установлением соединения. 
	\item SOCK\_SEQPACKET -- Аналог SOCK\_STREAM с дополнительным сохранением границ между записями. 
	\item SOCK\_DGRAM -- Передача данных в виде датаграмм в режиме без установления соединения. 
	\item SOCK\_RAW -- Аналог SOCK\_DGRAM с дополнительной возможностью доступа к протокольным заголовкам и другой информации нижнего уровня. Создавать сокеты этого типа могут лишь процессы с соответствующими привилегиями. В русскоязычной литературе часто фигурируют под именами ``неструктурированные'' или ``сырые'' сокеты.
\end{itemize}

Для каждого адресного семейства каждый тип сокета может поддерживаться одним или несколькими протоколами. В частности, в адресном семействе AF\_INET для сокетов типа SOCK\_STREAM подразумеваемым является протокол с именем IPPROTO\_TCP, а для типа SOCK\_DGRAM --- IPPROTO\_UDP; посредством неструктурированных сокетов (SOCK\_RAW) можно воспользоваться протоколом ICMP, задав имя IPPROTO\_ICMP, и т.д. 

\section{API сокетов}
\subsection{Получение имен хостов}

Структура hostent определена в файле {\tt netdb.h}:
\begin{lstlisting}[language=C]
#include <netdb.h>

struct hostent {
	char  *h_name;            /* official name of host */
	char **h_aliases;         /* alias list */
	int    h_addrtype;        /* host address type */
	int    h_length;          /* length of address */
	char **h_addr_list;       /* list of addresses */
	}
#define h_addr h_addr_list[0] /* for backward compatibility */
\end{lstlisting}
\begin{itemize}
\item h\_name -- официальное имя хоста;
\item h\_aliases -- массив псевдонимов хоста, завершающийся указателем на NULL;
\item h\_addrtype -- тип адреса (на данный момент {\tt AF\_INET} или {\tt AF\_INET6};
\item h\_length -- длина адреса в байтах;
\item h\_addr\_list -- массив указателей на сетевые адреса хоста, завершающийся указателем на NULL;
\item 
\end{itemize}

\lstinputlisting[caption="Получение списка хостов из локальной БД"]{sockets/src/hostname.c}

Пример содержимого файла {\tt /etc/hosts}:
\begin{verbatim}
127.0.0.1       alien.home      localhost.localdomain   localhost
::1     alien.home      localhost6.localdomain6 localhost6
\end{verbatim}


Результат работы программы:
\begin{verbatim}
Официальное имя хоста: alien.home
Альтернативные имена:
  localhost.localdomain
  localhost
Тип адреса хоста: 2
Длина адреса хоста: 4
Сетевые адреса хоста:
 127 0 0 1
Официальное имя хоста: alien.home
Альтернативные имена:
  localhost6.localdomain6
  localhost6
Тип адреса хоста: 2
Длина адреса хоста: 4
Сетевые адреса хоста:
  127 0 0 1
\end{verbatim}

К базе возможен и произвольный доступ по ключам --- именам и адресам хостов с помощью функций {\tt gethostbyname} и {\tt gethostbyaddr}, однако они считаются устаревшими и из новой версии стандарта POSIX могут быть исключены. Вместо них предлагается использовать функции {\tt getnameinfo} и {\tt getaddrinfo()}.

\lstinputlisting[caption="Доступ к произвольным именам хостов с помощью getaddrinfo"]{sockets/src/getaddrinfo.c}
Результат работы программы:
\begin{verbatim}
Результаты для сервиса http
Адрес сокета: Порт: 80 IP-адрес: 74.125.43.103
Официальное имя хоста: bw-in-f103.1e100.net
Адрес сокета: Порт: 80 IP-адрес: 74.125.43.104
Официальное имя хоста: (null)
Адрес сокета: Порт: 80 IP-адрес: 74.125.43.105
Официальное имя хоста: (null)
Адрес сокета: Порт: 80 IP-адрес: 74.125.43.106
Официальное имя хоста: (null)
Адрес сокета: Порт: 80 IP-адрес: 74.125.43.147
Официальное имя хоста: (null)
Адрес сокета: Порт: 80 IP-адрес: 74.125.43.99
Официальное имя хоста: (null)
\end{verbatim}


