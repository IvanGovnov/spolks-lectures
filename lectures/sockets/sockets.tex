\chapter{Программный интерфейс взаимодействия сокетов Беркли}

В стандартах TCP/IP не даны подробные сведения о том,  каким образом прикладное ПО должно взаимодействовать с ПО протоколов TCP/IP; в них описаны только необходимые функциональные средства,  а возможность определять конкретные требования к реализации API-интерфейса предоставлена системным проектировщикам.

Интерфейс между TCP/IP и приложениями,  в которых используются эти протоколы,  определены неформально,  в виде рекомендаций,  а не требований.

Применение неформальной спецификации имеет свои преимущества и недостатки.

К преимуществам относятся гибкость и широкая применяемость,  что позволяет проектировщикам реализовывать протоколы TCP/IP для любых операционных систем. Также проектировщики имеют возможность использовать органихацию интерфейса,  наиболее подходящую для операционной системы (например процедурную или основанную на передаче сообщений).

Недостатком неформальной спецификации является то,  что ее применение может привести к появлению различий в отдельных деталях реализации интерфейса для каждой ОС. 

На практике существует лишь небольшое количество API-интерфейсов,позволяющих использовать протоколы TCP/IP во всех приложениях. На данный момент получили наиболее широкое распространение 3 интерфейса: 
\begin{itemize}
\item сокеты Беркли (сокеты,  интерфейс сокетов),  разработанный в ун-те Беркли; 
\item Windows Sockets, разработанный в компании Microsoft;
\item TLI (Transport Layer Interface), разработанный AT\&T для системы Unix версии System V.
\end{itemize}

\section{Функциональные средства интерфейса}

\begin{itemize}
\item распределение локальных ресурсов для связи;
\item задание локальной и удаленной оконечных точек связи;
\item инициирование соединения (клиент);
\item передача дейтаграммы (клиент);
\item ожидание входящего запроса на установление соединения (сервер);
\item передача или прием данных;
\item определение момента поступления данных;
\item выработка срочных данных;
\item обработка входящих срочных данных;
\item корректное завершение соединения;
\item обработка запроса на завершение соединения от удаленного участника соединения;
\item аварийное прекращение связи;
\item устранение последствий аварийных ситуаций или аварийного прекращения связи;
\item освобождение локальных ресурсов после завершения связи.
\end{itemize}


\section{Сокеты Berkeley}

В начале 80-х годов агенство ARPA финансировало работу группы разработчиков Калифорнийского университета в г.Беркли,  которые должны были создать программное обеспечение транспортных протоколов TCP/IP для системы Unix и предоставить разработанный ПО в распоряжение представителей других организаций.

Они решили применять уже существующие системные вызовы и вводить новые только для поддержки функций TCP/IP,  которые нельзя легко включить в существующий набор функций. Результаты этого проекта получили широкую известность под названием “API-интерфейса сокетов” или просто интерфейса сокетов,  а разработанная система стала называться Berkeley UNIX или просто UNIX . Протокол ТСР впервые появился в выпуске 4.1 дистрибутива BSD (Berkeley Software Distribution).

В дальнейшем система Berkeley UNIX была адаптированна для своих целей многими поставщиками компьютеров: Sun Microsystems,  Tektronix,  Digital Equipment Corporation. Таким образом интерфейс получил настолько широкое распространение,  что стал считаться стандартом де-факто. Корпорация Micosoft внесла свой вклад в распространение интерфейса,  разработав версию сокетов для своей операционной системы.

Проектировщики из BSD предусмотрели возможность применения различных семейств протоколов связи,  далеко выходящую за рамки протоколов TCP/IP. 
Среди них протоколы TCP/IP представлены единственным семейством PF\_INET. Они также предусмотрели,  
чтобы в приложениях необходимые операции связи определялись путем указания на тип требуемой службы,  
а не выбора имени протокола. Поэтому вместо указания на то,  что ему требуется соединение TCP,
приложение запрашивает службу типа потоковой передачи семейства протоколов Интернет.

API-интерфейс сокетов предоставляет обобщенные функции,  которые поддерживают сетевую связь с помощью многих возможных протоколов. В вызовах функций сокетов все протоколы TCP/IP упоминаются как одно семейство протоколов. Эти вызовы позволяют программистам указывать тип требуемой службы,  а не имя конкретного протокола.

\section{Понятие сокета}

Приложение,  которому требуется произвести операции ввода/вывода с файлов вызывает функцию {\tt open},  чтобы создать дескриптор файла,  применяемый для доступа к файлу. 

Для процесса существует отдельная таблица дескрипторов,  которая используется для хранения указателей на внутренние струкуры данных для файлов,  открытых процессом.

В API-интерфейсе сокетов реализовано новое абстрактное понятие для сетевой связи –-- сокет. Как и файл,  сокет обозначается целым числом,  называемым дескриптором сокета. Операционная система размещает дескрипторы сокетов в той же таблице дескрипторов,  что и дескрипторы файлов. Поэтому в приложении не может присутствовать и дескриптор файлов и дескриптор сокетов с одним и тем же значением.

В ОС предусмотрена отдельная системная функция {\tt socket},  вызываемая приложением для создания 
сокета (функция {\tt open} используется только для создания файлов). Общий замысел,  
который лёг в основу разработки интерфейса сокетов,  состоял в том,  чтобы для создания любого сокета
было достаточно одного системного вызова. Для указания точных сведений о назначении сокета
нужно выполнить еще несколько системных вызовов.

Сам сокет является универсальным средством ввода/вывода и может применяться для любой связи. Поэтому приложение должно указывать как он будет использоваться. В частности необходимо указать номера портов протокола и адреса локального и удаленного компьютеров. 

Для обеспечения свободы выбора представлений используемых адресов,  в каждом семействе протоколов спецификация сокета определяет семейство адресов для каждого типа адреса. Во всех протоколах TCP/IP применяется единственное представление адреса,  а семейство адресов обозначается как AF\_INET.

Между PF\_INET и AF\_INET часто возникает путаница,  в основном из-за того,  что эти константы имеют общее числовое значение и могут быть заменены между собой,  хотя это неправильно.

Для обозначения типа адреса используется структура:

\begin{lstlisting}[language=C]
struct sockaddr{
	u_char sa_len;
	u_short sa_family;
	char sa_data[14];
}
\end{lstlisting}

\begin{itemize}
\item sa\_len -- общая длина (только с BSD 4.4 );
\item sa\_family -- тип адреса;
\item sa\_data[14] -- значение адреса.
\end{itemize}

Для приложений,  которые используют исключительно TCP/IP,  для определения типа адреса достаточно использовать структуру:
\begin{lstlisting}[language=C]
struct sockaddr{
	u_char sin_len;
	u_short sin_family;
	u_short sin_port;
	struct in_addr sin_addr;
	char sin_zero[8];
}
\end{lstlisting}

\begin{itemize}
\item sin\_len -- общая длина (только с BSD 4.4 );
\item sin\_family -- тип адреса;
\item sin\_port -- номер порта протокола;
\item sin\_addr -- IP-адрес (иногда = u\_long);
\item sin\_zero[8] -- не используется (=0).
\end{itemize}

\section{API сокетов}
\subsection{Получение имен хостов}

Структура hostent определена в файле {\tt netdb.h}:
\begin{lstlisting}[language=C]
#include <netdb.h>

struct hostent {
	char  *h_name;            /* official name of host */
	char **h_aliases;         /* alias list */
	int    h_addrtype;        /* host address type */
	int    h_length;          /* length of address */
	char **h_addr_list;       /* list of addresses */
	}
#define h_addr h_addr_list[0] /* for backward compatibility */
\end{lstlisting}
\begin{itemize}
\item h\_name -- официальное имя хоста;
\item h\_aliases -- массив псевдонимов хоста, завершающийся указателем на NULL;
\item h\_addrtype -- тип адреса (на данный момент {\tt AF_INET} или {\tt AF_INET6};
\item h\_length -- длина адреса в байтах;
\item h\_addr\_list -- массив указателей на сетевые адреса хоста, завершающийся указателем на NULL;
\item 
\end{itemize}

\lstinputlisting[caption="Получение списка хостов из локальной БД"]{sockets/src/hostname.c}

