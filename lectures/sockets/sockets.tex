\chapter{Программный интерфейс взаимодействия сокетов Беркли}

В стандартах TCP/IP не даны подробные сведения о том,  каким образом прикладное ПО должно взаимодействовать с ПО протоколов TCP/IP; в них описаны только необходимые функциональные средства,  а возможность определять конкретные требования к реализации API-интерфейса предоставлена системным проектировщикам.

Интерфейс между TCP/IP и приложениями,  в которых используются эти протоколы,  определены неформально,  в виде рекомендаций,  а не требований.

Применение неформальной спецификации имеет свои преимущества и недостатки.

К преимуществам относятся гибкость и широкая применяемость,  что позволяет проектировщикам реализовывать протоколы TCP/IP для любых операционных систем. Также проектировщики имеют возможность использовать органихацию интерфейса,  наиболее подходящую для операционной системы (например процедурную или основанную на передаче сообщений).

Недостатком неформальной спецификации является то,  что ее применение может привести к появлению различий в отдельных деталях реализации интерфейса для каждой ОС. 

На практике существует лишь небольшое количество API-интерфейсов, позволяющих использовать протоколы TCP/IP во всех приложениях. На данный момент получили наиболее широкое распространение 3 интерфейса: 
\begin{itemize}
\item сокеты Беркли (сокеты,  интерфейс сокетов),  разработанный в ун-те Беркли; 
\item Windows Sockets, разработанный в компании Microsoft;
\item TLI (Transport Layer Interface), разработанный AT\&T для системы Unix версии System V.
\end{itemize}

\section{Функциональные средства интерфейса}

\begin{itemize}
\item распределение локальных ресурсов для связи;
\item задание локальной и удаленной оконечных точек связи;
\item инициирование соединения (клиент);
\item передача дейтаграммы (клиент);
\item ожидание входящего запроса на установление соединения (сервер);
\item передача или прием данных;
\item определение момента поступления данных;
\item выработка срочных данных;
\item обработка входящих срочных данных;
\item корректное завершение соединения;
\item обработка запроса на завершение соединения от удаленного участника соединения;
\item аварийное прекращение связи;
\item устранение последствий аварийных ситуаций или аварийного прекращения связи;
\item освобождение локальных ресурсов после завершения связи.
\end{itemize}


\section{Сокеты Berkeley}

В начале 80-х годов агенство ARPA финансировало работу группы разработчиков Калифорнийского университета в г.Беркли,  которые должны были создать программное обеспечение транспортных протоколов TCP/IP для системы Unix и предоставить разработанный ПО в распоряжение представителей других организаций.

Они решили применять уже существующие системные вызовы и вводить новые только для поддержки функций TCP/IP,  которые нельзя легко включить в существующий набор функций. Результаты этого проекта получили широкую известность под названием “API-интерфейса сокетов” или просто интерфейса сокетов,  а разработанная система стала называться Berkeley UNIX или просто UNIX . Протокол ТСР впервые появился в выпуске 4.1 дистрибутива BSD (Berkeley Software Distribution).

В дальнейшем система Berkeley UNIX была адаптированна для своих целей многими поставщиками компьютеров: Sun Microsystems,  Tektronix,  Digital Equipment Corporation. Таким образом интерфейс получил настолько широкое распространение,  что стал считаться стандартом де-факто. Корпорация Micosoft внесла свой вклад в распространение интерфейса,  разработав версию сокетов для своей операционной системы.

Проектировщики из BSD предусмотрели возможность применения различных семейств протоколов связи,  далеко выходящую за рамки протоколов TCP/IP. 
Среди них протоколы TCP/IP представлены единственным семейством PF\_INET. Они также предусмотрели,  
чтобы в приложениях необходимые операции связи определялись путем указания на тип требуемой службы,  
а не выбора имени протокола. Поэтому вместо указания на то,  что ему требуется соединение TCP,
приложение запрашивает службу типа потоковой передачи семейства протоколов Интернет.

API-интерфейс сокетов предоставляет обобщенные функции,  которые поддерживают сетевую связь с помощью многих возможных протоколов. В вызовах функций сокетов все протоколы TCP/IP упоминаются как одно семейство протоколов. Эти вызовы позволяют программистам указывать тип требуемой службы,  а не имя конкретного протокола.

\section{Основные понятия}

Под сетевым адресом понимается видимый в пределах сети идентификатор, используемый для обозначения оконечных точек сети. Адреса есть у определенных оконечных точек хостов, могут они быть и у хостов в целом \cite{intuit-galatenko-01}.

Данные о хостах как узлах сети хранятся в сетевой базе, допускающей и последовательный, и случайный доступ с возможностью поиска по именам и адресам хостов. 

Процесс присвоения сетевого адреса оконечной точке называется связыванием, или привязкой, а обратное действие - освобождением, или отменой привязки. 

Обычно оконечной точкой служит аппаратный сетевой интерфейс, посредством которого данные передаются и принимаются, однако с таким интерфейсом, как шлейфовый (loopback), никакой аппаратуры не ассоциировано. 

Поддерживается база данных маршрутизации, используемая при выборе сетевого интерфейса для передачи порции данных (сетевого пакета). 

Данные передаются по сети в виде последовательности октетов (восьмибитных беззнаковых величин). Если некоторый элемент данных (например, адрес или номер порта) состоит более чем из восьми бит, для его передачи и хранения требуется несколько октетов. Сетевым называется порядок октетов (байт), при котором первый (с наименьшим адресом) октет содержит старшие (наиболее значимые) биты. 

Последовательности октетов - неудобный объект обработки на хостах, где предпочтительнее аппаратно поддерживаемые типы, в особенности целочисленные. Значения этих типов обычно хранятся с другим порядком байт, называемым хостовым, поэтому вполне возможно, что старшего бита не окажется в первом байте и вообще будет использоваться некое неочевидное распределение бит по байтам. 

Для преобразования значений типов {\tt uint16\_t} и {\tt uint32\_t} из хостового порядка байт в сетевой служат функции {\tt htons} и {\tt htonl}, функции {\tt ntohs} и {\tt ntohl} осуществляют обратную операцию. 

При взаимодействии процессов оконечными точками служат сокеты, они трактуются стандартом POSIX-2001 как отдельный тип файлов.

Под адресом сокета как (удаленной) оконечной точки понимается структура, включающая идентификатор адресного семейства и адресную информацию, специфичную для данного семейства. Последняя может состоять из нескольких компонентов, в том числе сетевого адреса хоста и идентификатора конкретной оконечной точки. 

Приложение,  которому требуется произвести операции ввода/вывода с файлом, вызывает функцию {\tt open},  чтобы создать дескриптор файла,  применяемый для доступа к файлу. 

Для процесса существует отдельная таблица дескрипторов,  которая используется для хранения указателей на внутренние струкуры данных для файлов, открытых процессом.

В API-интерфейсе сокетов реализовано новое абстрактное понятие для сетевой связи –-- {\bf сокет}. Как и файл,  сокет обозначается целым числом,  называемым дескриптором сокета. Операционная система размещает дескрипторы сокетов в той же таблице дескрипторов,  что и дескрипторы файлов. Поэтому в приложении не может присутствовать и дескриптор файлов и дескриптор сокетов с одним и тем же значением.

В ОС предусмотрена отдельная системная функция {\tt socket},  вызываемая приложением для создания 
сокета (функция {\tt open} используется только для создания файлов). Общий замысел,  
который лёг в основу разработки интерфейса сокетов,  состоял в том,  чтобы для создания любого сокета
было достаточно одного системного вызова. Для указания точных сведений о назначении сокета
нужно выполнить еще несколько системных вызовов.

Сам сокет является универсальным средством ввода/вывода и может применяться для любой связи. Поэтому приложение должно указывать, как он будет использоваться. В частности необходимо указать номера портов протокола и адреса локального и удаленного компьютеров. 

Для обозначения типа адреса используется структура:

\begin{lstlisting}[language=C]
struct sockaddr{
	u_char sa_len;
	u_short sa_family;
	char sa_data[14];
}
\end{lstlisting}
\begin{itemize}
\item sa\_len -- общая длина (только с BSD 4.4 );
\item sa\_family -- тип адреса;
\item sa\_data[14] -- значение адреса.
\end{itemize}

Для обеспечения свободы выбора представлений используемых адресов,  в каждом семействе протоколов спецификация сокета определяет семейство адресов для каждого типа адреса. Во всех протоколах TCP/IP применяется единственное представление адреса,  а семейство адресов обозначается как AF\_INET.

Адресное семейство соответствует конкретной среде взаимодействия. Стандарт POSIX-2001 определяет три таких семейства:
\begin{itemize}
	\item AF\_UNIX -- Адресное семейство UNIX поддерживает межпроцессное взаимодействие в пределах одной системы. Формально это можно считать вырожденным случаем сетевого взаимодействия. Описания, специфичные для данного семейства, содержатся в заголовочном файле <sys/un.h>. 
	\item AF\_INET -- Адресное семейство, поддерживающее взаимодействие по протоколам IPv4. 
		Специфичные для него описания располагаются в заголовочном файле <netinet/in.h>. 
	\item AF\_INET6 -- Взаимодействие по протоколам IPv6 (необязательная возможность). 
		За счет поддержки адресов IPv6, отображенных на IPv4, обеспечивается совместимость с приложениями, 
		использующими IPv4. Применяемые эти адресным семейством описания распределены по заголовочным 
		файлам <netinet/in.h>, <arpa/inet.h> и <netdb.h>. 
\end{itemize}

Между PF\_INET и AF\_INET часто возникает путаница,  в основном из-за того,  что эти константы имеют общее числовое значение и могут быть заменены между собой,  хотя это неправильно.

Для приложений,  которые используют исключительно TCP/IP,  для определения типа адреса достаточно использовать структуру:
\begin{lstlisting}[language=C]
struct sockaddr_in{
	u_char sin_len;
	u_short sin_family;
	u_short sin_port;
	struct in_addr sin_addr;
	char sin_zero[8];
}
\end{lstlisting}

\begin{itemize}
	\item sin\_len -- общая длина (только с BSD 4.4 );
	\item sin\_family -- тип адреса;
	\item sin\_port -- номер порта протокола;
	\item sin\_addr -- IP-адрес (иногда = u\_long);
	\item sin\_zero[8] -- не используется (=0).
\end{itemize}

В пределах каждого адресного семейства могут существовать сокеты нескольких типов. В стандарте POSIX-2001 их четыре:
\begin{itemize}
	\item SOCK\_STREAM -- Сокеты данного типа поддерживают надежные, упорядоченные, полнодуплексные потоки октетов в режиме с установлением соединения. 
	\item SOCK\_SEQPACKET -- Аналог SOCK\_STREAM с дополнительным сохранением границ между записями. 
	\item SOCK\_DGRAM -- Передача данных в виде датаграмм в режиме без установления соединения. 
	\item SOCK\_RAW -- Аналог SOCK\_DGRAM с дополнительной возможностью доступа к протокольным заголовкам и другой информации нижнего уровня. Создавать сокеты этого типа могут лишь процессы с соответствующими привилегиями. В русскоязычной литературе часто фигурируют под именами ``неструктурированные'' или ``сырые'' сокеты.
\end{itemize}

Для каждого адресного семейства каждый тип сокета может поддерживаться одним или несколькими протоколами. В частности, в адресном семействе AF\_INET для сокетов типа SOCK\_STREAM подразумеваемым является протокол с именем IPPROTO\_TCP, а для типа SOCK\_DGRAM --- IPPROTO\_UDP; посредством неструктурированных сокетов (SOCK\_RAW) можно воспользоваться протоколом ICMP, задав имя IPPROTO\_ICMP, и т.д. 

\section{API сокетов}
\subsection{Сетевой и хостовый порядок байт}

Преобразование значений типов {\tt uint16\_t} и {\tt uint32\_t} из хостового порядка 
байт в сетевой выполняется посредством функций {\tt htons} и {\tt htonl},
а функции {\tt ntohs} и {\tt ntohl} осуществляют обратную операцию.

\begin{lstlisting}[language=C, caption="Описание функций преобразования целочисленных значений из хостового порядка байт в сетевой и наоборот."]
#include <arpa/inet.h>
uint32_t htonl (uint32_t hostlong);
uint16_t htons (uint16_t hostshort);
uint32_t ntohl (uint32_t netlong);
uint16_t ntohs (uint16_t netshort);
\end{lstlisting}

\subsection{Получение имен хостов}

Структура hostent определена в файле {\tt netdb.h}:
\begin{lstlisting}[language=C]
#include <netdb.h>

struct hostent {
	char  *h_name;            /* official name of host */
	char **h_aliases;         /* alias list */
	int    h_addrtype;        /* host address type */
	int    h_length;          /* length of address */
	char **h_addr_list;       /* list of addresses */
	}
#define h_addr h_addr_list[0] /* for backward compatibility */
\end{lstlisting}

\begin{itemize}
\item h\_name -- официальное имя хоста;
\item h\_aliases -- массив псевдонимов хоста, завершающийся указателем на NULL;
\item h\_addrtype -- тип адреса (на данный момент {\tt AF\_INET} или {\tt AF\_INET6};
\item h\_length -- длина адреса в байтах;
\item h\_addr\_list -- массив указателей на сетевые адреса хоста, завершающийся указателем на NULL;
\end{itemize}

Доступ к сетевой базе имен хостов осуществляется с помощью вызовов:
\begin{lstlisting}[language=C]
#include <netdb.h>
void sethostent (int stayopen);
struct hostent *gethostent (void);
void endhostent (void);

struct hostent *gethostbyname(const char *name);

#include <sys/socket.h>       /* for AF_INET */
struct hostent *gethostbyaddr(const void *addr,
				socklen_t len, int type);
\end{lstlisting}

\begin{itemize}
	\item {\tt sethostent} -- устанавливает соединение с базой, остающееся открытым после вызова {\tt gethostent}, если значение аргумента {\tt stayopen} отлично от нуля.
	\item {\tt gethostent} -- последовательно читает элементы базы, возвращая результат в структуре типа {\tt hostent}.
	\item {\tt endhostent} -- закрывает соединение с базой.
	\item {\tt gethostbyname} -- возвращает результат в структуре типа {\tt hostent} для заданного имени хоста.
	\item {\tt gethostbyaddr} -- возвращает результат в структуре типа {\tt hostent} для заданного в структуре {\tt addr}.	
\end{itemize}


\lstinputlisting[caption="Получение списка хостов из локальной БД"]{sockets/src/hostname.c}

Пример содержимого файла {\tt /etc/hosts}:
\begin{verbatim}
127.0.0.1       alien.home      localhost.localdomain   localhost
::1     alien.home      localhost6.localdomain6 localhost6
\end{verbatim}


Результат работы программы:
\begin{verbatim}
Официальное имя хоста: alien.home
Альтернативные имена:
  localhost.localdomain
  localhost
Тип адреса хоста: 2
Длина адреса хоста: 4
Сетевые адреса хоста:
 127 0 0 1
Официальное имя хоста: alien.home
Альтернативные имена:
  localhost6.localdomain6
  localhost6
Тип адреса хоста: 2
Длина адреса хоста: 4
Сетевые адреса хоста:
  127 0 0 1
\end{verbatim}

Произвольный доступ по ключам --- именам и адресам хостов с помощью функций {\tt gethostbyname} и {\tt gethostbyaddr} считаются устаревшим и эти функции могут быть исключены из новой версии стандарта POSIX. Вместо них необходимо использовать функции {\tt getnameinfo} и {\tt getaddrinfo()}.

\begin{lstlisting}[language=C]
#include <sys/socket.h>
#include <netdb.h>

void freeaddrinfo (struct addrinfo *ai);

int getaddrinfo 
    (const char *restrict nodename, 
	const char *restrict servname,
	const struct addrinfo *restrict hints,
	struct addrinfo **restrict res);

int getnameinfo 
	(const struct sockaddr *restrict sa, 
	socklen_t salen, char *restrict node, 
	socklen_t nodelen, char *restrict service,
	socklen_t servicelen, int flags);
\end{lstlisting}

Аргумент {\tt hints} позволяет передать дополнительную информацию об опрашиваемом сервисе - адресное семейство, тип сокета, протокол, флаги. 
Согласно стандарту, структура {\tt addrinfo}, описанная в заголовочном файле {\tt <netdb.h>}, должна содержать по крайней мере следующие поля. 

\begin{verbatim}
int              ai_flags; /* Входные флаги */
int              ai_family; /* Адресное семейство сокета */
int              ai_socktype; /* Тип сокета */
int              ai_protocol; /* Протокол сокета */
socklen_t        ai_addrlen; /* Длина адреса сокета */
struct sockaddr *ai_addr; /* Адрес сокета */
char            *ai_canonname; /* Официальное имя узла сети */
struct addrinfo *ai_next; /* Указатель на следующий элемент списка */
\end{verbatim}

\lstinputlisting[caption=Доступ к произвольным именам хостов с помощью getaddrinfo]{sockets/src/getaddrinfo.c}

Результат работы программы:
\begin{verbatim}
Результаты для сервиса http
Адрес сокета: Порт: 80 IP-адрес: 74.125.43.103
Официальное имя хоста: bw-in-f103.1e100.net
Адрес сокета: Порт: 80 IP-адрес: 74.125.43.104
Официальное имя хоста: (null)
Адрес сокета: Порт: 80 IP-адрес: 74.125.43.105
Официальное имя хоста: (null)
Адрес сокета: Порт: 80 IP-адрес: 74.125.43.106
Официальное имя хоста: (null)
Адрес сокета: Порт: 80 IP-адрес: 74.125.43.147
Официальное имя хоста: (null)
Адрес сокета: Порт: 80 IP-адрес: 74.125.43.99
Официальное имя хоста: (null)
\end{verbatim}

Для преобразования IP-адресов из текстового представления в числовое и наоборот можно использовать функции:
\begin{lstlisting}[language=C]
#include <arpa/inet.h>
in_addr_t inet_addr (const char *cp);
char *inet_ntoa (struct in_addr in);
int inet_pton (int af, const char 
     *restrict src, void *restrict dst);
const char *inet_ntop (int af, const void 
     *restrict src, char *restrict dst, 
     socklen_t size);
\end{lstlisting}

\subsection{Доступ к базе данных сетевых протоколов}
Локальная база данных сетевых протоколов располагается по адресу {\tt /etc/protocols}, а содержимое этого файла выглядит следующим образом:
\begin{verbatim}
ip	0	IP		# internet protocol, pseudo protocol number
icmp	1	ICMP		# internet control message protocol
igmp	2	IGMP		# internet group management protocol
tcp	6	TCP		# transmission control protocol
udp	17	UDP		# user datagram protocol
\end{verbatim}

Доступ к базе данных сетевых протоколов осуществляется с помощью следующих вызовов:
\begin{lstlisting}[language=C]
#include <netdb.h>
void setprotoent (int stayopen);
struct protoent *getprotoent (void);
struct protoent *getprotobyname 
            (const char *name);
struct protoent *getprotobynumber
			(int proto);
void endprotoent (void);
\end{lstlisting}

Структура {\tt protoent} содержит по крайней мере следующие поля:
\begin{itemize}
	\item char  *p\_name -- официальное имя протокола;
	\item char **p\_aliases -- массив указателей на альтернативные имена протокола, завершаемый пустым указателем;
	\item int    p\_proto -- номер протокола.
\end{itemize}

\lstinputlisting[caption=Пример программы для получения списка протоколов]{sockets/src/protoname.c}

Результат работы программы:
\begin{verbatim}
Официальное имя протокола: ip
Альтернативные имена:
  IP
Номер протокола: 0

Официальное имя протокола: icmp
Альтернативные имена:
  ICMP
Номер протокола: 1

Официальное имя протокола: igmp
Альтернативные имена:
  IGMP
Номер протокола: 2
\end{verbatim}


\subsection{Доступ к базе данных сетевых сервисов}
Локально база данных сетевых сервисов располагается по адресу {\tt /etc/services}, а содержимое этого файла выглядит следующим образом:
\begin{verbatim}
# service-name  port/protocol  [aliases \ldots]   [# comment]
domain		53/tcp				# Domain Name Server
domain		53/udp				# Domain Name Server
bootps		67/tcp				# Bootstrap Protocol Server
bootps		67/udp				# Bootstrap Protocol Server
bootpc		68/tcp				# Bootstrap Protocol Client
bootpc		68/udp				# Bootstrap Protocol Client
\end{verbatim}

Доступ к базе данных сетевых сервисов осуществляется с помощью следующих вызовов:
\begin{lstlisting}[language=C]
#include <netdb.h>
void setservent (int stayopen);
struct servent *getservent (void);
struct servent *getservbyname 
     (const char *name, const char *proto);
struct servent *getservbyport 
     (int port, const char *proto);
void endservent (void);
\end{lstlisting}

Структура {\tt servent} содержит следующие поля:
\begin{itemize}
	\item char  *s\_name -- Официальное имя сервиса
	\item char **s\_aliases -- Массив указателей на альтернативные имена сервиса, завершаемый пустым указателем
	\item int    s\_port -- Номер порта, соответствующий сервису (в сетевом порядке байт)
	\item char  *s\_proto -- Имя протокола для взаимодействия с сервисом
\end{itemize}

\lstinputlisting[caption=Пример программы для получения списка сервисов]{sockets/src/servname.c}

Результат работы программы:
\begin{verbatim}
Официальное имя сервиса: http
Альтернативные имена:
  www
  www-http
Номер порта: 80
Имя протокола: tcp

Официальное имя сервиса: http
Альтернативные имена:
  www
  www-http
Номер порта: 80
Имя протокола: udp

Официальное имя сервиса: kerberos
Альтернативные имена:
  kerberos5
  krb5
Номер порта: 88
Имя протокола: tcp
\end{verbatim}

\subsection{Функции для работы с сокетами}
В этом разделе кратко описан минимальный набор системных вызовов, входящий в стандарт POSIX \cite{man-pages-01} \cite{man-pages-02}.

\subsubsection{socket}
{\tt socket} --- создать оконечную точку коммуникации   

\begin{lstlisting}[language=C]
#include <sys/types.h> 
#include <sys/socket.h> 
int socket(int domain, int type, int protocol);   
\end{lstlisting}

Вызов {\tt socket} создает оконечную точку для коммуникации и возвращает её дескриптор. 

Параметр {\tt domain} задает ``домен'' коммуникации; выбирает набор протоколов, которые будут использоваться для коммуникации.

Такие наборы описаны в <sys/socket.h>. Примеры форматов: 

\begin{itemize}
\item PF\_UNIX,PF\_LOCAL -- Локальная коммуникация
\item PF\_INET --	IPv4, протоколы Интернет
\item PF\_INET6 -- IPv6, протоколы Интернет
\item PF\_IPX -- IPX -- протоколы Novell
\item PF\_NETLINK -- Устройство для общения пользователя с ядром
\item PF\_X25 -- Протокол ITU-T X.25 / ISO-8208
\item PF\_AX25 -- Протокол AX.25, любительское радио 
\item PF\_APPLETALK -- Appletalk
\item PF\_PACKET -- Низкоуровневый пакетный интерфейс
\end{itemize}

Сокет имеет тип {\tt type}, задающий семантику коммуникации. Стандарт POSIX определяет следующие типы:

\begin{itemize}
	\item SOCK\_STREAM 
	\item SOCK\_SEQPACKET
	\item SOCK\_DGRAM
	\item SOCK\_RAW
\end{itemize}


Параметр {\tt protocol} задает конкретный протокол, который используется на сокете. 
Обычно существует только один протокол, обеспечивающий конкретный тип сокета в 
заданном наборе протоколов. Однако, возможно существование нескольких таких 
протоколов -- тогда и используется этот параметр. 
Номер протокола зависит от используемого домена коммуникации.

 В случае ошибки возвращается -1; в противном случае возвращается дескриптор, ссылающийся на сокет. 

\subsubsection{connect}
{\tt connect} --- инициирует соединение на сокете.

\begin{lstlisting}[language=C]
#include <sys/types.h> 
#include <sys/socket.h> 
int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen); 
\end{lstlisting}

Файловый дескриптор {\tt sockfd} должен ссылаться на сокет. 
Если сокет имеет тип {\tt SOCK\_DGRAM}, значит, адрес {\tt serv\_addr} является 
адресом по умолчанию, куда посылаются датаграммы, и единственным адресом, откуда 
они принимаются. Если сокет имеет тип {\tt SOCK\_STREAM} или {\tt SOCK\_SEQPACKET},
то данный системный вызов попытается установить соединение с другим сокетом.
Другой сокет задан параметром {\tt serv\_addr}, являющийся адресом длиной 
{\tt addrelen} в пространстве коммуникации сокета. Каждое пространство коммуникации 
интерпретирует параметр {\tt serv\_addr} по-своему.

Обычно сокеты с протоколами, основанными на соединении, могут устанавливать 
соединение только один раз; сокеты с протоколами без соединения могут 
использовать {\tt connect} многократно, чтобы изменить адрес назначения. 
Сокеты без поддержки соединения могут прекратить связь с другим сокетом, 
установив член {\tt sa\_family} структуры sockaddr в {\tt AF\_UNSPEC}.

Если соединение или привязка прошла успешно, возвращается нуль. 
При ошибке возвращается -1, а {\tt errno} устанавливается должным образом.

\subsubsection{listen}
{\tt listen} -- слушать соединения на сокете (перевести сокет в пассивный режим).

\begin{lstlisting}[language=C]
#include <sys/socket.h> 
int listen(int s, int backlog);   
\end{lstlisting}

Для того, чтобы принимать соединения, сначала нужно создать сокет с 
помощью {\tt socket}, затем выразить готовность принимать входящие соединения 
и задать размер очереди с помощью {\tt listen}, а затем вызывать {\tt accept} 
по мере появления новых соединений. Системный вызов {\tt listen} применим 
только к сокетам типа {\tt SOCK\_STREAM} или {\tt SOCK\_SEQPACKET}.

Параметр {\tt backlog} задает максимальную длину, до которой может расти очередь 
ожидающих соединений. Если приходит запрос на соединение, а очередь полна,
то клиент получит ошибку {\tt ECONNREFUSED} или, если соответствующий
протокол поддерживает повторную передачу, запрос может быть игнорирован,
чтобы попытаться ответить на повторный запрос.   

В случае успеха возвращается нуль. 
При ошибке возвращается -1, а {\tt errno} устанавливается должным образом.

\subsubsection{accept}

\begin{lstlisting}[language=C]

\end{lstlisting}


\subsubsection{bind}
\subsubsection{send}
\subsubsection{recv}
\subsubsection{close}
\subsubsection{shutdown}
\subsubsection{setsockopt}
\subsubsection{getsockopt}

