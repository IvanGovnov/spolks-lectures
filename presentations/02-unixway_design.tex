% СПО ЛКС - проектирование ПО
% Пынькин Д.А. (с) 2011
\input{common}

\subtitle{Программы, протоколы, форматы данных и не только...}

%
% Далее начинается сама презентация
%
\begin{document}
\begin{frame}
\titlepage
\begin{center}
e-mail: denis.pynkin@bsuir.by\\
\end{center}
\begin{center}
{\bfseries http://goo.gl/32cTB}

{\tiny СЧАСТЬЕ ДЛЯ ВСЕХ, ДАРОМ, И ПУСТЬ НИКТО НЕ УЙДЕТ ОБИЖЕННЫЙ!\\
(c)Стругацкие, Пикник на обочине}
\end{center}
\end{frame}

\section{Философия}

\begin{frame}{Главные ориентиры}
	\begin{itemize}
		\item кроссплатформенная переносимость
			\pause
		\item открытые стандарты
	\end{itemize}
\end{frame}

\begin{frame}{Немного цитат}
Дуг Макилрой, изобретатель каналов <<pipes>>, сформулировал несколько постулатов,применимых для разработки ПО:
\pause
	\begin{itemize}
		\item пишите программы,  которые выполняют одну функцию и делают это хорошо;
			\pause
		\item пишите программы,  которые будут работать вместе;
			\pause
		\item пишите программы,  поддерживающие текстовые потоки,  поскольку они являются универсальным интерфейсом.
	\end{itemize}

\end{frame}


\begin{frame}{"Философия" UNIX}
	это {\bfseries не} философия,  а общие рекомендации по проектированию ПО,  накопленные сообществом программистов на опыте десятилетий разработок программ,  которые взаимодействуют друг с другом.
\end{frame}

\begin{frame}{1. Правило модульности}
	\begin{block}{Следует писать простые части,  связанные ясными интерфейсами.}
		\pause
Единственным способом создания сложной программы,  не обреченной заранее на провал,  является сдерживание ее глобальной сложности.
	\end{block}
	\pause
Т.е. построение программы из простых частей, соединенных четко определенными интерфейсами, 
так что большинство проблем являются локальными, 
и тогда можно рассчитывать на обновление одной из частей без разрушения целого.
\end{frame}

\begin{frame}{Размер кода и ошибки}
	\begin{center}
		\includegraphics[width=200px]{02-errors_density-graph.png}
	\end{center}
\end{frame}

\begin{frame}{2. Правило ясности}
	\begin{block}{Ясность -- лучше чем мастерство.}
		\pause
		Последующее обслуживание программы -- важная и дорогостоящая часть жизненного цикла программы.
	\end{block}
	\pause
Писать программы необходимо так,  как если бы вы знали,  что последующей поддержкой будет заниматься неуравновешенный псих с топором,  знающий ваш домашний адрес!
\end{frame}

\begin{frame}{3. Правило композиции}
	\begin{block}{Следует разрабатывать программы,  которые будут взаимодействовать с другими программами.}
		\pause
		Если разрабатываемые программы не способны взаимодействовать друг с другом,  то очень трудно избежать создания сложных монолитных  программ.
	\end{block}
	\pause
	Методы взаимодействия могут быть сильными и слабыми -- по возможности рекомендуется использовать слабые методы и текстовые форматы передачи данных.
\end{frame}

\begin{frame}{4. Правило разделения}
	\begin{block}{Следует отделять политику от механизма и интерфейсы от основных модулей (engine).}
		Примеры политики и механизма:\\
		вид GUI и операции отрисовки, клиент (front-end) -- сервер (back-end), сценарии и библиотеки и др.
	\end{block}
	\pause
	При жесткой связи политики и механизма:
	\begin{itemize}
		\item политика становится негибкой и усложняется ее изменение;
		\item изменение политики имеет строгую тенденцию к дестабилизации механизмов.
	\end{itemize}
\end{frame}

\begin{frame}{5. Правило простоты}
	\begin{block}{Необходимо проектировать простые программы и <<добавлять сложность>> только там,  где это необходимо.}
	\end{block}
	\pause
	Основные причины добавления сложности:
	\begin{itemize}
		\item человеческий фактор (часто -- желание <<выпендриться>>);
		\item проектные требования,  продиктованные текущей модой,  маркетингом или «левой пяткой заказчика»;
	\end{itemize}
\end{frame}

\begin{frame}{6. Правило расчетливости}
	\begin{block}{Пишите большие программы,  только если после демонстрации становится ясно,  что ничего другого не остается.}
		Под <<большими программами>> здесь понимаются программы с большим объемом кода и значительной внутренней сложностью.
	\end{block}
\end{frame}

\begin{frame}{7. Правило прозрачности}
	\begin{block}{Для того,  чтобы упростить проверку и отладку программы,  ее конструкция должна быть обозримой.}
		\pause
		Программа {\itshape прозрачна}, если при ее минимальном изучении можно понять, что она делает и как.\\
		\pause
		Программа {\itshape воспринимаема},  когда она имеет средства для мониторинга и отображения внутреннего состояния.
	\end{block}
	\pause
	Необходимо использовать достаточно простые форматы входных и выходных данных.\\
	Интерфейс должен быть приспособлен для использования в отладочных сценариях.
\end{frame}

\begin{frame}{8. Правило устойчивости}
	\begin{block}{Устойчивость -- следствие	прозрачности и простоты.}
		\pause
		Программа является {\itshape устойчивой},  когда она выполняет свои функции в неожиданных условиях,  которые выходят за рамки предположений разработчика,  как и в нормальных условиях.\\
		\pause
		Программа является {\itshape простой},  если происходящее в ней не представляется сложным для восприятия человеком.
	\end{block}
	\pause
	Один из способов организации -- модульность(простые блоки,  ясные интерфейсы)\\
	Следует избегать частных случаев!
\end{frame}

\begin{frame}[fragile]{Пример <<простой>> программы}
	\begin{center}
		\begin{verbatim}
+++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++.+++++++++++++++++
++++++++++++.+++++++..+++.-------------------
---------------------------------------------
---------------.+++++++++++++++++++++++++++++
++++++++++++++++++++++++++.++++++++++++++++++
++++++.+++.------.--------.------------------
---------------------------------------------
----.-----------------------.
		\end{verbatim}
	\end{center}
\end{frame}

\begin{frame}{9. Правило представления}
	\begin{block}{Знания следует оставлять в данных,  чтобы логика программы могла быть примитивной и устойчивой.}
		\pause
		Даже простую логику бывает сложно проверить,  но даже сложные структуры данных являются довольно простыми для моделирования и анализа (например диаграмма 50 узлов дерева и блок-схема 50 строк кода)
	\end{block}
	\pause
	Если можно выбирать между усложнением структуры данных и усложнением кода,  то лучше выбирать первое.\\
	Примеры: ascii,  генератор html-таблицы.
\end{frame}

\begin{frame}{10. Правило наименьшего удивления}
	\begin{block}{При проектировании интерфейсов всегда следует использовать наименее неожиданные элементы.}
		\pause
		Необходимо учитывать характер предполагаемой аудитории и традиции платформы.
	\end{block}
	\pause
	Оборотная сторона: следует избегать создания внешне похожих вещей,  слегка отличающихся в действительности,  поскольку {\itshape кажущаяся привычность порождает ложные ожидания}.
\end{frame}

\begin{frame}{11. Правило тишины}
	\begin{block}{Если программе нечего сказать,  то пусть лучше молчит.}
		\pause
		Внимание и сосредоточенность пользователя -- ценный и ограниченный ресурс,  который требуется только в случае необходимости.
	\end{block}
	\pause
	Важная информация не должна смешиваться с подробными сведениями о работе программы.
\end{frame}

\begin{frame}{12. Правило восстановления}
	\begin{block}{Когда программа завершается аварийно,  это должно происходить явно (шумно) и по возможности быстро.}
		\pause
		Если программа не способна справиться с ошибкой,  то необходимо завершить ее работу так,  чтобы максимально упростить диагностику.
	\end{block}
	\pause
	Для сетевых служб следует следовать рекомендации Постела:\\
	<<{\itshape Будьте либеральны к тому,  что принимаете,  и консервативны к тому,  что отправляете}>>
\end{frame}

\begin{frame}{13. Правило экономии}
	\begin{block}{Время программиста дорого -- поэтому задача экономии его времени более приоритетна,  по сравнению с экономией машинного времени.}
		\pause
		Компьютер железный -- ему не скучно (с) программистская мудрость
	\end{block}
	\pause
	Использование высокоуровневых языков и <<обучение>> машины выполнять больше низкоуровневой работы по программированию,  что приводит к правилу 14.
\end{frame}

\begin{frame}{14. Правило генерации}
	\begin{block}{Избегайте кодирования вручную; если есть возможность -- пишите программы для создания программ.}
		\pause
		Использование генераторов кода оправданно,  когда они могут повысить уровень абстракции,  
		т.е. когда язык спецификации для генератора проще,  чем сгенерированный код,  
		и код впоследствии не потребует ручной доработки.
	\end{block}
	\pause
	Примеры: грамматические и лексические анализаторы,  генераторы make-файлов,  построители GUI-интерфейсов.
\end{frame}

\begin{frame}{15. Правило оптимизации}
	\begin{block}{Сначала -- опытный образец,  потом -- оптимизирование.}
		Добейтесь стабильной работы,  только потом оптимизируйте.
	\end{block}
	\pause
	\begin{block}{Керниган и Плоджер:}
		90\% актуальной и реальной функциональности лучше,  чем 100\% функциональности перспективной и сомнительной
	\end{block}
	\pause
	\begin{block}{Кнутт:}
		преждевременная оптимизация -- корень всех зол
	\end{block}
	\pause
	\begin{block}{Кент Бек (экстремальное программирование):}
		заставьте программу работать,  заставьте работать ее верно,  а затем сделайте ее быстрой
	\end{block}
\end{frame}

\begin{frame}{16. Правило разнообразия}
	\begin{block}{Не следует доверять утверждениям о <<единственно правильном пути>>.}
		\pause
		Никто не обладает умом,  достаточым для оптимизации всего или для предвидения всех возможных вариантов использования создаваемой программы.
	\end{block}
\end{frame}

\begin{frame}{17. Правило расширяемости}
	\begin{block}{Разрабатывайте для будущего. Оно наступит быстрее,  чем вы думаете.}
		\pause
		При проектировании протоколов или форматов файлов следует делать их самоописательными,  для того,  чтобы их можно было расширить.
	\end{block}
	\pause
	{\itshape Всегда},  следует либо включать номер версии,  либо составлять формат из самодостаточных,  
	самоописательных команд так,  чтобы можно было легко добавить новые директивы,  
	а старые удалить, <<не сбивая с толку>> код чтения формата.
\end{frame}

\begin{frame}{Все правила сразу}
	\begin{center}
	{\Huge\bfseries K.I.S.S.}

	\pause
	Keep It Simple,  Stupid!
	\end{center}
\end{frame}

\section{Представление данных}

\begin{frame}{Не повторяйтесь!}
	\begin{center}
	Правило\\
	{\Huge\bfseries SPOT}

	Single Point of Truth

	\end{center}
	\pause
	
	Внутри системы каждый блок знаний должен иметь единственное,  недвусмысленное и надежное представление.
\end{frame}


\begin{frame}{Дублирование данных?}
	Если дублирование данных существует из-за необходимости иметь два различных представления в 
	двух различных местах,  то возможно ли написать функцию,  средство или генератор кода для 
	создания одного представления из другого или обоих из общего источника?
\end{frame}

\begin{frame}{Дублирование данных?}
Если документация дублирует данные из кода,  то можно ли создать фрагменты документации 
из кода или наоборот,  или и то,  и другое из общего представления более высокого уровня?
\end{frame}

\begin{frame}{Дублирование данных?}
	Если файлы заголовков и объявления интерфейсов дублируют сведения в реализации кода,  
	то существует ли способ создания файлов заголовков и объявлений интерфейсов из данного кода?
\end{frame}

\begin{frame}{SPOT для структур данных}
	\begin{block}{<<нет лишнего — нет путаницы>>}
		Предпочтительна структура данных,  состояния которой имеют однозначное 
		соответствие с состояниями реальной системы,  которая будет моделироваться.
	\end{block}
\end{frame}

\begin{frame}{Представление данных}
	\begin{center}
	{\Large\bfseries Ясные протоколы лежат в основе хорошей практики.}
	\end{center}
\end{frame}

\begin{frame}{Схожесть задач}
	\begin{itemize}
		\item Проектирование форматов файлов для сохранения данных приложений в постоянном хранилище данных.
		\item Проектирование протоколов прикладного уровня для передачи (в том числе и через сеть) данных и команд между взаимодействующими программами.
	\end{itemize}
\end{frame}

\begin{frame}{Важное при проектировании прикладных протоколов}
	\begin{itemize}
		\item способность к взаимодействию; 
			\pause
		\item прозрачность;
			\pause
		\item расширяемость;
			\pause
		\item экономичность транзакций.
	\end{itemize}
\end{frame}

\begin{frame}{Типы данных}
	С машинной точки зрения удобно хранить данные сложной структуры в бинарном виде -- все поля имеют характерный для конкретной машины формат и указатели в виде адресов.

	\pause
	{\itshape Однако такие формы представления не подходят для хранения и передачи.}
\end{frame}

\begin{frame}{Сериализация данных}
	Часто ЯП и/или платформа предоставляет средства для сериализации данных и восстановления исходной структуры из байтового потока.
\end{frame}

\begin{frame}{Минусы сериализации данных при использовании в протоколах}
	\begin{itemize}
		\item проблемы взаимодействия между машинами с разной архитектурой;
			\pause
		\item непрозрачность для других средств;
			\pause
		\item для сетевых протоколов часто целесообразно представлять структуру данных не в виде одного большого двоичного объекта,  а в виде последовательности транзакций или сообщений,  которые могут быть отклонены принимающей машиной.
	\end{itemize}
\end{frame}


\begin{frame}{Когда выгодно использовать бинарное представление?}
	\begin{itemize}
		\item Необходимость передачи больших блоков данных и разработчик формата действительно позаботился о достижении максимальной плотности полезной информации в потоке.

			Пример: мультимедиа форматы.
			\pause
		\item Существует жесткое ограничение времени и/или инструкций,  необходимых для интерпретации данных.

			Пример: протоколы сетевого уровня.
	\end{itemize}
\end{frame}

\begin{frame}{Текстовое представление данных}
	Дуг Макилрой (изобретатель pipes):
	\begin{itemize}
		\item Будьте готовы к тому,  что вывод каждой программы станет вводом другой,  еще неизвестной программы. 
			\pause
		\item Не загромождайте вывод посторонней информацией. 
			\pause
		\item Избегайте строгих табличных или двоичных форматов ввода. 
			\pause
		\item Не настаивайте на интерактивном вводе.
	\end{itemize}
\end{frame}

\begin{frame}{Текстовые потоки -- универсальный формат передачи данных}
	Они просты для чтения,  записи и редактирования человеком без использования специальных инструментов.
	\pause

	{\itshape Текстовые форматы -- прозрачны.}
\end{frame}

\begin{frame}{Текстовые потоки -- универсальный формат передачи данных}
	Если необходима производительность,  то можно внедрить сжатие текстового потока на уровне выше или ниже.

	Часто такая конструкция является более производительной,  чем бинарное представление.
\end{frame}

\begin{frame}{Текстовые потоки -- универсальный формат передачи данных}
	Упрощается интерпретация и анализ взаимодействия приложений,  а также написание тестовых программ.
\end{frame}

\begin{frame}{Текстовые потоки -- универсальный формат передачи данных}
	Серверные процессы часто запускаются с помощью суперсерверов подобных inetd/xinetd,  так что сервер получает команды на стандартный ввод и отправляет ответ на стандартный вывод.
\end{frame}

\begin{frame}{Текстовые потоки -- универсальный формат передачи данных}
	Можно взаимодействовать с сервером или клиентом с помощью программ {\tt telnet} или {\tt netcat}.
\end{frame}

\begin{frame}[fragile]{Пример: POP3}
\tiny
	{\bfseries telnet pop.mail.ru 110}\\
	\color{gray}
	Trying 94.100.177.6...\\
	Connected to pop.mail.ru.\\
	Escape character is '\^]'.\\
	\color{black}
	S: +OK\\
	{\bfseries C: USER test\_testerson@mail.ru}\\
	S: +OK\\
	{\bfseries C: PASS test01}\\
	S: +OK Welcome!\\
	{\bfseries C: STAT}\\
	S: +OK 2 95232\\
	{\bfseries C: LIST}\\
	S: +OK 2 messages (95232 octets)\\
	S: 1 40269\\
	S: 2 54853\\
	S: .\\
	{\bfseries C: RETR 1}\\
	S: +OK 40269 octets\\
	{\color{gray}  Here is the message}\\
	{\bfseries C: DELE 1}\\
	S: +OK message 1 deleted\\
	{\bfseries C: QUIT}\\
	S: +OK POP3 server at mail.ru signing off\\
\normalsize
\end{frame}


\begin{frame}{}
\end{frame}

\end{document}
%Конец файла
