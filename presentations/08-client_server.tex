% СПО ЛКС - Архитектура клиент-сервер 
% Пынькин Д.А. (с) 2011
\input{common}

\subtitle{Модель сетевого взаимодействия клиент-сервер}

\begin{document}

\mode<all>{\input{titlepage}}

%
% Далее начинается сама презентация
%
%\section{}

\begin{frame}{}
	\Huge
	\begin{center}
		Алгоритмы и задачи проектирования серверного программного обеспечения
	\end{center}
\end{frame}

\begin{frame}{Концептуальный алгоритм}

	По сути каждый сервер функционирует по следующему алгоритму: \\
в нем создается сокет и выполняется привязка сокета к порту. \\
Затем сервер входит в бесконечный цикл,  в котором он принимает очередной запрос,  поступающий от клиента,  обрабатывает этот запрос,  формирует ответ и отправляет его клиенту. 
\end{frame}

\begin{frame}{}

	{\itshape Время обработки запроса сервером} -- это общее количество времени,  которое требуется серверу для обработки одного отдельно взятого запроса
	
	{\itshape Время отклика} -- задержка между временем отправки клиентом запроса и временем получения ответа от сервера.

	\bigskip	
	Время отклика всегда больше времени обработки запроса,  однако при применении очереди запросов,  подлежащих обработке,  отклик может занимать  значительно больше времени нежели время обработки запроса. 
\end{frame}

\begin{frame}{Классификация серверов}
	\begin{block}{По внутренней архитектуре}
		\begin{itemize}
			\item Последовательный
			\item Параллельный
		\end{itemize}
	\end{block}
	\pause
	\begin{block}{По типу используемого сервиса}
		\begin{itemize}
			\item С установлением соединения
			\item Без установления соединения
		\end{itemize}
	\end{block}
	\pause
	\begin{block}{По состоянию}
		\begin{itemize}
			\item С сохранением состояния (stateful)
			\item Без сохранения состояния (stateless)
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}{Варианты параллелизма}

	{\itshape Многопоточное решение} применяется,  если затраты на создание и переключение между потоками невелики 
и при этом требуется совместное использование или обмен данными между соединениями.\\
\pause
{\itshape Многопроцессная модель} применяется для достижения максимального распараллеливания. Если используются процессы,  то появляется возможность использовать для обработки внешние программы.\\
\pause
При использовании {\itshape асинхронного ввода/вывода} обработка запросов ведется только в одном потоке,
поэтому сервер имеет практически такую же производительность,  что и последовательный,  даже на компьютере с несколькими процессорами. 
Удобно применять, если сервер должен иметь доступ к данным разных соединений или на обработку каждого запроса не требуется много времени.
\end{frame}



\begin{frame}{Серверы с установлением логического соединения}

	Преимущества:
	\begin{itemize}
		\item простота программирования
	\end{itemize}

Недостатки:
	\begin{itemize}
		\item для каждого логического соединения требуется создавать отдельный сокет
		\item требуется трехэтапное квитирование при установке и разрыве соединения,  что невыгодно для использования передачи небольших объемов данных в небольшой сети
		\item простаивающее соединение,  по которому не проходят пакеты,  напрасно используют ресурсы
	\end{itemize}
\end{frame}

\begin{frame}{Серверы без установления логического соединения}

	Преимущества:
	\begin{itemize}
		\item нет накладных расходов на установление и разрыв соединения
		\item можно реализовывать широковещательные или групповые рассылки
		\item не требуются ресурсы на поддержание соединения
	\end{itemize}

Недостатки:
	\begin{itemize}
		\item самостоятельная реализация механизмов управления передачей: квитирование, тайм-ауты, оптимизация трафика, контроль надежности
	\end{itemize}
\end{frame}

\begin{frame}{stateful \& stateless серверы}

{\itshape Информация о состоянии} -- это обновляемая сервером информация о ходе взаимодействия с клиентом.

Информация о состоянии применяется для эффективной оптимизации сервера.

Если на сервере сохраняются какие-либо данные о запросах клиента, то: 
	\begin{itemize}
		\item можно значительно сократить объем передаваемой информации и ускорить работу сервера
		\item информация о состоянии также может сохраняться для использования даже в случае перезагрузки сервера. 
	\end{itemize}
\end{frame}

\begin{frame}{stateful \& stateless серверы}

	Отрицательная сторона: информация о состоянии,  хранящаяся на сервере,  может стать ошибочной,
	если сообщения были потеряны,  продублированы или доставлены не в исходном порядке,  
	либо если клиент аварийно перезапустился. 
	Соответственно и ответ сервера,  основанный на ошибочной информации может быть ошибочным.
\end{frame}

\begin{frame}{Основные типы сервера}
	\begin{itemize}
		\item Последовательный сервер без установления логического соединения
		\item Последовательный сервер с установлением логического соединения
		\item Параллельный сервер без установления логического соединения
		\item Параллельный сервер с установлением логического соединения
	\end{itemize}
\end{frame}

\begin{frame}{Последовательный сервер без установления логического соединения}

	Используется в службах,  требующих незначительного времени для обработки каждого запроса
\end{frame}

\begin{frame}{Последовательный сервер с установлением логического соединения}
Используется в службах,  требующих незначительного времени для обработки каждого запроса,  
однако требующих надежного протокола доставки сообщений. 
За счет больших издержек на установку и завершение соединения среднее время отклика часто значительно выше,  чем у предыдущего сервера.
\end{frame}

\begin{frame}{Параллельный сервер без установления логического соединения}

	Редко применяемый тип сервера. 
	
	Во многих случаях затраты на создание потоков или процессов не оправдывают повышения эффективности,  достигнутого за счет параллелизма.
\end{frame}

\begin{frame}{Параллельный сервер с установлением логического соединения}

	Наиболее распространенный тип сервера,  поскольку сочетает надежный протокол (подходит и для глобальных сетей) с возможностью одновременной работы с несколькими клиентами.
\end{frame}

\begin{frame}{}
	\Huge
	\begin{center}
		Алгоритмы серверов
	\end{center}
\end{frame}

\begin{frame}{Последовательный сервер с установлением логического соединения}

	\begin{enumerate}
		\item Создать сокет и привязать его к общепринятому адресу службы
		\item Перевести сокет в пассивный режим
		\item Принять из сокета запрос на установление соединения и получить новый сокет для установления соединения
		\item Считывать в цикле запросы от клиента,  формировать ответы и отправлять их клиенту,  в соответствии с прикладным протоколом
		\item После завершения обмена данными с клиентом закрыть соединение и перейти к 3 пункту
	\end{enumerate}
\end{frame}

\begin{frame}{Последовательный сервер без установления логического соединения}
	\begin{enumerate}
		\item Создать сокет и привязать его к общепринятому адресу службы
		\item Считывать в цикле запросы от клиента,  формировать ответы и отправлять их клиенту,  в соответствии с прикладным протоколом
	\end{enumerate}
\end{frame}

\begin{frame}{Параллельный сервер без установления логического соединения}

Ведущий поток:
	\begin{enumerate}
		\item Создать сокет и привязать его к общепринятому адресу службы
		\item В цикле считывать запросы с помощью {\tt recvfrom} и создавать новые ведомые потоки (процессы) для формирования ответа
	\end{enumerate}
\pause
Ведомый поток:
	\begin{enumerate}
		\item Работа потока начинается с получения конкретного запроса от ведущего потока,  а также доступа к сокету
		\item Сформировать ответ согласно прикладному протоколу и отправить его клиенту с использованием функции {\tt sendto}
		\item Завершить работу потока
	\end{enumerate}
\end{frame}

\begin{frame}{Параллельный сервер с установлением логического соединения}

Ведущий поток:
	\begin{enumerate}
		\item Создать сокет и привязать его к общепринятому адресу службы
		\item Перевести сокет в пассивный режим
		\item Вызвать в цикле функцию {\tt accept} для получения очередного запроса от клиента и создавть новый ведомый поток или процесс для формирования ответа
	\end{enumerate}
\pause
Ведомый поток:
	\begin{enumerate}
		\item Работа начинается с получения доступа к соединению,  полученному от ведущего потока
		\item Выполнять в цикле работу с клиентом через соединение
		\item Закрыть соединение и завершить работу.
	\end{enumerate}
\end{frame}

\begin{frame}{Cервер с асинхронным вводом/выводом}

	\begin{enumerate}
		\item Создать сокет и привязать его к общепринятому адресу службы. Добавить сокет к списку сокетов,  через которые может осуществляться ввод/вывод
		\item Использовать функцию {\tt select} для получения информации о готовности существующих сокетов к вводу/выводу
		\item Если готов первоначальный сокет, то использовать функцию {\tt accept} для получения очередного запроса на установление соединения и добавить новый сокет к списку сокетов,  через которые может осуществляться ввод/вывод
		\item Если готов сокет,  отличный от первоначального,  использовать функцию {\tt recv} для получения очередного запроса,  сформировать ответ и передать ответ клиенту с использованием функции {\tt send}
		\item Перейти к пункту 2
	\end{enumerate}
\end{frame}

\begin{frame}{}
	\Huge
	\begin{center}
		Примеры
	\end{center}
\end{frame}

\begin{frame}[fragile]{Пример создания серверного сокета}
	\scriptsize	
\begin{lstlisting}[Language=C]
int servsock(  char *host,  char * service,  char * proto,  
		struct sockaddr_in	*sin) {
  int sd;
  if ( (sd = mksock( host,  service,  proto,  (struct sockaddr_in *) sin)) == -1)
    return -1;
  if( bind( sd,  (struct sockaddr *) sin,  sizeof( *sin)) < 0) {
    perror( "Ошибка при привязке сокета");
    return -1;
  }

  if( strcmp( proto,  "tcp") == 0) {
    if ( listen( sd,  qlen) == -1) {
      perror( "Ошибка при переводе сокета в пассивный режим");
	  return -1;
    }
  }
  return sd;
}
\end{lstlisting}
	\normalsize
\end{frame}

\begin{frame}[fragile]{Последовательный сервер без установления логического соединения}
	\scriptsize	
\begin{lstlisting}[Language=C]
main( void)
{
char *host = "amok.evm", *service = "2525", *proto = "udp";
struct sockaddr_in sin, remote;
struct timeval timev;
int sd, rlen, readed;
char buf[513], *t_now;
    if ( (sd = servsock( host, service, proto,  &sin, 10)) == -1) {
      printf( "Ошибка при создании сокета\n");
      return 1;
    }
    while(1){
      rlen = sizeof( remote);
      if( (readed = recvfrom( sd, buf, 512, 0, (struct sockaddr *)&remote, &rlen)) != -1) {
        gettimeofday( &timev, NULL);
        t_now = ctime( &(timev.tv_sec));
        sendto(sd, t_now, strlen(t_now), 0, (struct sockaddr *)&remote, sizeof					(remote));
      }
    }
    return 0;
}
\end{lstlisting}
	\normalsize

\end{frame}

\begin{frame}[fragile]{Последовательный сервер с установлением логического соединения}
	\scriptsize	
\begin{lstlisting}[Language=C]
main( void)
{
...
char * proto = "tcp";
int sd, rsd, rlen, readed;
...
    while(1) {
      rlen = sizeof( remote);
      rsd = accept( sd, (struct sockaddr *)&remote, &rlen);
      if( (readed = recv(rsd, buf, 512,0)) != -1) {
        gettimeofday( &timev, NULL);
        t_now = ctime( &(timev.tv_sec));
        send(rsd, t_now, strlen(t_now), 0);
      }
      close( rsd);
    }
    return 0;
}
\end{lstlisting}
	\normalsize
\end{frame}

\begin{frame}[fragile]{Реализация параллельного сервера с установлением логического соединения с помощью процессов}
	\scriptsize	
\begin{lstlisting}[Language=C]
while(1) {
  rlen = sizeof( remote);
  rsd = accept( sd, (struct sockaddr *)&remote, &rlen);
  switch( fork()) {
    case -1:
      exit(ERR);
    case 0:
      close( sd);
      exit ( TCP_Proc ( rsd) );
    default:
      close( rsd);
  }
}
\end{lstlisting}
	\normalsize

\end{frame}

\begin{frame}[fragile]{Реализация параллельного сервера с установлением логического соединения с помощью потоков}
	\scriptsize	
\begin{lstlisting}[Language=C]
pthread_t th;
pthread_attr_t ta;

  while(1) {
    rlen = sizeof( remote);
    rsd = accept( sd, (struct sockaddr *)&remote, &rlen);
    pthread_create (&th,&ta, TCP_Proc, rsd);
  }
\end{lstlisting}
	\normalsize
\end{frame}

\begin{frame}[fragile]{Пример реализации сервера с асинхронным вводом/выводом}
	\scriptsize
\begin{lstlisting}[Language=C]
fd_set rfds, afds;
int nfds;
  nfds = getdtablesize();
  FD_ZERO( &afds);
  FD_SET( sd, &afds);
  while(1) {
    memcpy( &rfds, &afds, sizeof(rfds));	
    if ( select( nfds, &rfds, (fd_set *) 0, (fd_set *) 0, (struct timeval *) 0) <0)
      return 2;
    if( FD_ISSET( sd, &rfds))	{
      rlen = sizeof( remote);
      rsd = accept( sd, (struct sockaddr *)&remote, &rlen);
      FD_SET( rsd, &afds);
    }
    for( rsd=0; rsd < nfds; ++rsd)
      if( (rsd != sd) && FD_ISSET( rsd, &rfds)) {
        TCP_Proc( rsd);
        close( rsd);
        FD_CLR( rsd, &afds);
      }
  }
\end{lstlisting}
	\normalsize

\end{frame}


\begin{frame}{Альтернативное устройство параллельного сервера}

	\begin{itemize}
		\item предварительное создание дочерних процессов (preforking)
		\item предварительное создание потоков (prethreading)
		\item мультисервисные серверы (суперсервер)
	\end{itemize}
\end{frame}
\mode<all>{\input{lastpage}}

\end{document}
%Конец файла
