% СПО ЛКС - Архитектура клиент-сервер 
% Пынькин Д.А. (с) 2011
\input{common}

\subtitle{Модель сетевого взаимодействия клиент-сервер}

\begin{document}

\mode<all>{\input{titlepage}}

%
% Далее начинается сама презентация
%
%section{Введение}

\begin{frame}{Архитектура}

	Термин "клиент-сервер" означает такую архитектуру программного комплекса, 
в которой его функциональные части взаимодействуют по схеме "запрос-ответ". 
\end{frame}

\begin{frame}{Клиент или сервер?}
	
	\begin{block}{С сетевой точки зрения}
Если рассмотреть две взаимодействующие части этого комплекса,  то одна из них (клиент) выполняет активную функцию,  т. е. инициирует запросы,  а другая (сервер) пассивно на них отвечает.
	\end{block}
По мере развития системы роли могут меняться,  например некоторый программный блок будет одновременно выполнять функции сервера по отношению к одному блоку и клиента по отношению к другому.
\end{frame}

\begin{frame}{Клиент или сервер?}

	\begin{block}{С функциональной точки зрения}
Процессы,  реализующие некоторую службу,  например ФС или БД называются серверами. 

Процессы,  запрашивающие службы у серверов службы путем пересылки запроса и последующего ожидания ответа от сервера,  называются клиентами.
	\end{block}
\end{frame}

\begin{frame}{Сетевое взаимодействие}
	\begin{center}
		\includegraphics[height=0.8\textheight]{07-cs_arch.png}
	\end{center}
\end{frame}

\begin{frame}{Модель?}

	Модель клиент-сервер всегда была предметом множества дебатов и споров. Один из главных вопросов состоял в том,  как точно разделить клиента и сервер.
	
	Четкого разделения здесь не может быть.
\end{frame}

\begin{frame}{Трехуровневая модель}

	\begin{itemize}
		\item уровень пользовательского интерфейса
		\item уровень обработки
		\item уровень данных
	\end{itemize}
\end{frame}

\begin{frame}{Уровень пользовательского интерфейса}

Уровень пользовательского интерфейса обычно реализуется на клиентах. Этот уровень содержит программы,  посредством которых пользователь может взаимодействовать с приложением. 

Простейший вариант пользовательского интерфейса не содержит ничего,  кроме символьного (или графического) дисплея.
\end{frame}

\begin{frame}{Уровень обработки}

	На этом уровне трудно выделить какие-то закономерности,  обычно здесь реализуется логика работы программы. 
\end{frame}

\begin{frame}{Уровень данных}
	
	На этом уровне находятся программы,  которые поставляют данные обрабатывающим их приложениям. 

	В простейшем варианте уровень данных реализуется файловой системой,  однако часто может использоваться и полнофункциональная база данных.  В модели клиент-сервер этот уровень обычно находится на стороне сервера.

	\pause
	Специфическим требованием этого уровня является требование сохранности – это означает,  что когда приложение не работает,  данные должны сохраняться в определенном месте в расчете на дальнейшее использование. \\
\end{frame}

\begin{frame}{Физически двухзвенная архитектура}
	\begin{center}
		\includegraphics[width=1\textwidth]{07-2_layers.png}
	\end{center}
\end{frame}

\begin{frame}{Физически трехзвенная архитектура}
	\begin{center}
		\includegraphics[height=0.8\textheight]{07-3_layers.png}
	\end{center}
\end{frame}


\begin{frame}{}
	\begin{block}{Вертикальное распределение}
Во множестве приложений обработка данных организована как многозвенная архитектура приложений клиент-сервер.
Особенностью такого типа является то,   что он    о достигается размещением логически разных компонентов на различных физических машинах.
	\end{block}
	\pause
	\begin{block}{Горизонтальное распределение}
При таком типе распределения клиент или сервер может содержать физически разделенные части логически однородного модуля,  причем работа с каждой из частей может протекать независимо. Это делается для выравнивания нагрузки.
	\end{block}
	\pause
	\begin{block}{peer-to-peer}
Для некоторых несложных приложений выделенного сервера может не быть вообще. Такую организацию обычно называют одноранговым распределением.
	\end{block}
\end{frame}

\begin{frame}{Модель взаимодействия типа клиент-сервер и проектирование ПО}

С точки зрения прикладного программиста,  протоколы TCP/IP,  как и большинство других протоколов
компьютерной связи,  просто предоставляет основные механизмы передачи данных. 
В частности протоколы  TCP/IP,  позволяют устанавливать соединение между 2-мя прикладными программами 
и передавать данные в прямом и обратном направлении. 

Поэтому {\itshape принято считать}, что протоколы  TCP/IP обеспечивают одноранговую или прямую связь.
\end{frame}

\begin{frame}{Основная модель сетевого взаимодействия}

Необходимость применения принципа организации взаимодействия типа клиент-сервер связана с решением проблемы согласования условий соединения.

Модель взаимодействия типа клиент-сервер предусматривает согласование условий соединения наиболее простым способом:\\ 
\bigskip
она требует,  чтобы для взаимодействия любой пары приложений,  один из участников приступал к работе заранее и ждал (возможно в течение неопределенного времени) до тех пор,  пока к нему не обратится второй участник соединения.
\end{frame}

\begin{frame}{}

	\begin{center}
		{\Huge Архитектура клиента}
	\end{center}
\end{frame}

\begin{frame}{}

	Приложения действующие в качестве клиентов концептуально проще приложений выполняющих функции серверов.
	\begin{itemize}
		\item основной части клиентского программного обеспечения не нужно взаимодействовать с несколькими серверами
			\pause
		\item основная часть клиентского программного обеспечения применяется в виде обычных прикладных программ -- не требуются привилегии
			\pause
		\item большая часть клиентского обеспечения не заботится о правилах защиты,  поскольку в этом вопросе оно полагается на ОС
	\end{itemize}

\end{frame}

\begin{frame}{Определение местонахождения сервера}

	{\itshape Определение местонахождения сервера -- первейшая и одна из самых выжных задач клиентского программного обеспечения!!!}
\pause
	\begin{itemize}
		\item доменное имя или IP-адрес сервера могут быть заданы в виде константы во время трансляции клиентской программы
			\pause
		\item клиентская программа может требовать у пользователя указывать имя сервера при ее вызове
			\pause
		\item информация о местонахождении сервера предоставляется из постоянного хранилища данных
			\pause
		\item для поиска сервера используется отдельный протокол
	\end{itemize}
\end{frame}

\begin{frame}{Определение местонахождения сервера}
Еще один аспект поиска сервера следует из того,  какой тип сервиса предоставляется сервером. 

От этого зависит нужно ли использовать какой-либо определенный сервер или же можно использовать первый ответивший. 

В качестве альтернативы в ответе сервера может также содержаться список других серверов.
\end{frame}

\begin{frame}{Алгоритм клиентов с установлением логического соединения}
Задача построения клиента с использованием протокола TCP является самой простой из всех задач сетевого программирования.

Алгоритм клиента TCP:
\begin{enumerate}
	\item Найти IP-адрес и номер порта протокола сервера,  с которым необходимо установить связь.
	\item Распределить сокет
	\item Указать,  что для соединения нужен произвольный,  неиспользуемый порт протокола на локальном компьютере и позволить ПО TCP выбрать такой порт
	\item Подключить сокет к серверу
	\item Выполнить обмен данными с сервером по протоколу прикладного уровня
	\item Закрыть соединение
\end{enumerate}
\end{frame}

\begin{frame}{Анализ параметра адреса}
Хотя каждая клиентская программа может указывать адрес и порт по-своему, существует общепринятый синтаксис этих параметров:
\begin{itemize}
	\item сначала имя, а вторым параметром порт \\
		{\tt telnet server port}
	\item имя и порт рассматриваются как один параметр, разделенный двоеточием\\
		{\tt lftp -e ls ftp.mgts.by:21}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Пример: функция для создания сокета}
\tiny
	\begin{lstlisting}
int mksock( char *host,  char * service,  char * proto,  struct sockaddr_in *sin)
{
struct hostent *hptr;
struct servent *sptr;
struct protoent *pptr;
int sd=0,  type;

  memset( sin,  0,  sizeof( *sin));
  sin->sin_family = AF_INET;

  if( hptr = gethostbyname( host))
    memcpy( & sin->sin_addr,  hptr->h_addr,  hptr->h_length);
  else	return -1;

  if ( ! ( pptr = getprotobyname( proto)) )  return -1;

  if( sptr = getservbyname( service,  proto))
    sin->sin_port = sptr->s_port;
  else 
  if( (sin->sin_port = htons(( unsigned short) atoi (service))) == 0) return -1;

  if ( strcmp( proto,  "udp") == 0)
    type = SOCK_DGRAM;
  else
    type = SOCK_STREAM;
	
  if ( (sd = socket( PF_INET,  type,  pptr->p_proto)) < 0){
    perror( "Ошибка при распределении сокета");
    return -1;
  }
  return sd;
}
\end{lstlisting}
\normalsize
\end{frame}

\begin{frame}[fragile]{Пример: создание сокета}
\tiny
	\begin{lstlisting}

#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>

int mksock( char *host,  char * service,  char * proto,  struct sockaddr_in *sin);

main( void)
{

char * host = "pop.gmail.com";
char * service = "imap";
char * proto = "tcp";
struct sockaddr_in sin;
int sd;

 if ( sd = mksock( host,  service,  proto,   &sin) == -1) {
    printf( "Ошибка при создании сокета\n");
    return 1;
 }

 printf( "Адрес сервера %s = %s\n",  host,  inet_ntoa( sin.sin_addr));
 printf( "Адрес порта %s = %X\n",  service,   sin.sin_port);
 
 return 0;
}

	\end{lstlisting}
\normalsize
\end{frame}


\begin{frame}[fragile]{Пример: создание сокета\\результат работы программы}
\scriptsize
	\begin{verbatim}
Адрес сервера pop.gmail.com = 74.125.39.108
Адрес порта imap = 143
	\end{verbatim}
\normalsize
\end{frame}


\begin{frame}{Подключение сокета к TCP серверу}

	Производится с помощью вызова {\tt connect}. Этот вызов выполняет 4 задачи:
	\begin{enumerate}
		\item проверяет,  является ли сокет действительным и не был ли он подключен
		\item заполняет поле адреса конечной точки в дескрипторе сокета (из 2-го параметра)
		\item выбирает локальный адрес в дескрипторе сокета,  если он еще не задан
		\item инициирует соединение TCP и возвращает результат в вызывающую программу
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Взаимодействие с сервером при использовании TCP}

	Если соединение установлено,  то обычно прикладной протокол определяет взаимодействие по принципу запрос-ответ. Для этого используется вызовы {\tt send} и {\tt recv} ({\tt write} и {\tt read}).

Поскольку ПО TCP не учитывает границ между записями,  то в любой программе,  принимающей данные из соединения TCP,  необходимо предусмотреть возможность получения данных в виде фрагментов,  составляющих лишь несколько байтов.

\scriptsize
	\begin{lstlisting}
char *req,  *buf;

send( sd,  req,  strlen(req),  0)

while( n = recv( sd,  buf,  buflen,  0) > 0 ){
  buf += n;
  buflen -= n;
}
	\end{lstlisting}
\normalsize

\end{frame}

\begin{frame}{Закрытие соединения TCP}

Для корректного завершения соединения и освобождения сокета вызывается функция {\tt close}.
Однако часто возникает ситуация,  когда сервер не знает будут ли еще приходить запросы от 
клиента и наоборот,  когда клиент не знает все ли данные выдал сервер. 

Механизм частичного закрытия {\tt shutdown} позволяет устранить неопределенность в работе прикладных протоколов,
которые передают произвольный объем информации в ответ на запрос. 
В таких случаях клиент выполняет операцию частичного закрытия после передачи последнего запроса; 
затем сервер закрывает соединение после передачи последнего ответа.

\end{frame}

\begin{frame}{Алгоритм клиентов без установления логического соединения}

	В этом алгоритме проблема надежности игнорируется.
	\begin{enumerate}
		\item Найти IP-адрес и номер порта протокола сервера,  с которым необходимо установить связь.
		\item Распределить сокет
		\item Указать,  что для соединения нужен произвольный,  неиспользуемый порт протокола на локальном компьютере и позволить ПО UDP выбрать такой порт
		\item Указать сервер,  на который должны передаваться сообщения.
		\item Выполнить обмен данными с сервером по протоколу прикладного уровня
		\item Закрыть сокет
	\end{enumerate}
\end{frame}

\begin{frame}{Подключенный и неподключенный режимы}

В клиентском приложении сокет UDP может использоваться в одном из 2-х основных режимов: 
подключенном и неподключенном. 

Подключенные сокеты удобно применять для взаимодействия с конкретным сервером,
а неподключенные – если адресат может меняться,  в этом случае нужно для каждого сообщения указывать адрес сервера.

Если используется подключение,  то вызов функции {\tt connect} только записывает информацию 
об удаленной точке в дескриптор сокета. Даже если вызов успешен,  это еще не означает,  что адрес удаленной точки действителен или что сервер является достижимым.
\end{frame}

\begin{frame}{Закрытие соединения UDP}

	Применение функции {\tt close} приводит к тому,  что ПО UDP будет отбрасывать все дальнейшие пакеты.
	При этом удаленная сторона не информируется о закрытии соединения,  поэтому приложения нужно 
проектировать таким образом,  чтобы удаленный участник знал,как долго сокет 
должен оставаться доступным до его закрытия.

Вызов функции {\tt shutdown} не отправляет каких-либо сообщений удаленной стороне и сокет просто помечается,  как неприменимый для передачи данных в указанном направлении.
\end{frame}

\begin{frame}{Ненадежность UDP}

	Клиентское ПО,  в котором используется протокол UDP,  должно обеспечивать надежность с помощью различных методов,  таких как контроль за последовательностью поступления пакетов,  подтверждения,  тайм-ауты и повторная передача.
	
	Проектирование правильных,  надежных и эффективных протоколов для больших сетей требуют большого опыта.
\end{frame}

\mode<all>{\input{lastpage}}

\end{document}
%Конец файла
