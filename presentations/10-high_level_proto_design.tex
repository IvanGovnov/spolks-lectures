% СПО ЛКС - проектирование пользовательских протоколов
% Пынькин Д.А. (с) 2011
\input{common}

\subtitle{Форматы данных \\и проектирование пользовательских протоколов}

\begin{document}

\mode<all>{\input{titlepage}}

%
% Далее начинается сама презентация
%

\section{Представление данных}

\begin{frame}{Представление данных}
	\begin{center}
	{\Large\bfseries Ясные протоколы лежат в основе хорошей практики.}
	\end{center}
\end{frame}

\begin{frame}{Схожесть задач}
	\begin{itemize}
		\item Проектирование форматов файлов для сохранения данных приложений в постоянном хранилище данных.
		\item Проектирование протоколов прикладного уровня для передачи (в том числе и через сеть) данных и команд между взаимодействующими программами.
	\end{itemize}
\end{frame}

\begin{frame}{Важное при проектировании прикладных протоколов}
	\begin{itemize}
		\item способность к взаимодействию; 
			\pause
		\item прозрачность;
			\pause
		\item расширяемость;
			\pause
		\item экономичность транзакций.
	\end{itemize}
\end{frame}

\begin{frame}{Типы данных}
	С машинной точки зрения удобно хранить данные сложной структуры в бинарном виде -- все поля имеют характерный для конкретной машины формат и указатели в виде адресов.

	\pause
	{\itshape Однако такие формы представления слабо подходят для длительного хранения и передачи.}
\end{frame}

\begin{frame}{Сериализация данных}
	Часто ЯП и/или платформа предоставляет средства для сериализации данных и восстановления исходной структуры из байтового потока.
\end{frame}

\begin{frame}{Минусы сериализации данных при использовании в протоколах}
	\begin{itemize}
		\item проблемы взаимодействия между машинами с разной архитектурой;
			\pause
		\item непрозрачность для других средств;
			\pause
		\item для сетевых протоколов часто целесообразно представлять структуру данных не в виде одного большого двоичного объекта,  а в виде последовательности транзакций или сообщений,  которые могут быть отклонены принимающей машиной.
	\end{itemize}
\end{frame}


\begin{frame}{Когда выгодно использовать бинарное представление?}
	\begin{itemize}
		\item Необходимость передачи больших блоков данных и разработчик формата действительно позаботился о достижении максимальной плотности полезной информации в потоке.

			Пример: мультимедиа форматы.
			\pause
		\item Существует жесткое ограничение времени и/или инструкций,  необходимых для интерпретации данных.

			Пример: протоколы сетевого уровня.
	\end{itemize}
\end{frame}

\begin{frame}{Текстовое представление данных}
	Дуг Макилрой (изобретатель pipes):
	\begin{itemize}
		\item Будьте готовы к тому,  что вывод каждой программы станет вводом другой,  еще неизвестной программы. 
			\pause
		\item Не загромождайте вывод посторонней информацией. 
			\pause
		\item Избегайте строгих табличных или двоичных форматов ввода. 
			\pause
		\item Не настаивайте на интерактивном вводе.
	\end{itemize}
\end{frame}

\begin{frame}{Текстовые потоки -- универсальный формат передачи данных}
	Они просты для чтения,  записи и редактирования человеком без использования специальных инструментов.
	\pause

	{\itshape Текстовые форматы -- прозрачны.}
\end{frame}

\begin{frame}{Текстовые потоки -- универсальный формат передачи данных}
	Если необходима производительность,  то можно внедрить сжатие текстового потока на уровне выше или ниже.

	Часто такая конструкция является более производительной,  чем бинарное представление.
\end{frame}

\begin{frame}{Текстовые потоки -- универсальный формат передачи данных}
	Упрощается интерпретация и анализ взаимодействия приложений,  а также написание тестовых программ.
\end{frame}

\begin{frame}{Текстовые потоки -- универсальный формат передачи данных}
	Серверные процессы часто запускаются с помощью суперсерверов подобных inetd/xinetd,  так что сервер получает команды на стандартный ввод и отправляет ответ на стандартный вывод.
\end{frame}

\begin{frame}{Текстовые потоки -- универсальный формат передачи данных}
	Можно взаимодействовать с сервером или клиентом с помощью программ {\tt telnet} или {\tt netcat}.
\end{frame}

\begin{frame}{Пример: SMTP}
\scriptsize
	{\bfseries telnet smtp.mail.ru 25}\\
	\color{gray}
	Trying 94.100.177.1...\\
	Connected to smtp.mail.ru.\\
	Escape character is '\^]'.\\
	\color{black}
	S: 220 smtp3.mail.ru ESMTP ready\\
	{\bfseries C: HELO my.server.org}\\
	S: 250 smtp3.mail.ru\\
	{\bfseries C: MAIL FROM: test\_testerson@mail.ru}\\
	S: 250 2.0.0 OK\\
	{\bfseries C: RCPT TO: denis.pynkin@bsuir.by}\\
	S: 250 Accepted\\
	{\bfseries C: DATA}\\
	S: 354 Enter message,  ending with "." on a line by itself\\
	{\bfseries C: from: test\_testerson@mail.ru\\
	C: to: denis.pynkin@bsuir.by\\
	C: subject: test\\
	C: Test message\\
	C: .}\\
	S: 250 OK id=1PmNuu-0006QX-00\\
	{\bfseries C: QUIT}
\normalsize
\end{frame}



\begin{frame}[fragile]{Пример: POP3}
\scriptsize
	{\bfseries telnet pop.mail.ru 110}\\
	S: +OK\\
	{\bfseries C: USER test\_testerson@mail.ru}\\
	S: +OK\\
	{\bfseries C: PASS test01}\\
	S: +OK Welcome!\\
	{\bfseries C: STAT}\\
	S: +OK 2 95232\\
	{\bfseries C: LIST}\\
	S: +OK 2 messages (95232 octets)\\
	S: 1 40269\\
	S: 2 54853\\
	S: .\\
	{\bfseries C: RETR 1}\\
	S: +OK 40269 octets\\
	{\color{gray}  Here is the message}\\
	{\bfseries C: DELE 1}\\
	S: +OK message 1 deleted\\
	{\bfseries C: QUIT}\\
	S: +OK POP3 server at mail.ru signing off\\
\normalsize
\end{frame}


\begin{frame}{Пример: FTP}
Управляющее соединение FTP:\\
\medskip
\tiny
	{\bfseries telnet ftp.mgts.by 21}\\
	S: 220 Welcome to ByFly FTP service.\\
	{\bfseries C: USER anonymous}\\
	S: 331 Please specify the password.\\
	{\bfseries C: PASS test\_testerson@mail.ru}\\
	S: 230 Login successful.\\
	{\bfseries C: PASV}\\
	S: 227 Entering Passive Mode (86, 57, 151, 3, 47, 76)\\
	\% ip=86.57.151.3 port=47*256+76=12108\\
	{\bfseries C: LIST}\\
	\%\%\%\%\% Здесь устанавливается информационное соединение №1 \%\%\%\%\%\\
	S: 150 Here comes the directory listing.\\
	S: 226 Directory send OK.\\
	{\bfseries C: PASV}\\
	S: 227 Entering Passive Mode (86, 57, 151, 3, 191, 44)\\
	{\bfseries C: RETR README}\\
	\%\%\%\%\% Здесь устанавливается информационное соединение №2 \%\%\%\%\%\\
	S: 150 Opening BINARY mode data connection for README (197 bytes).\\
	S: 226 File send OK.\\
	{\bfseries C: QUIT}\\
	S: 221 Goodbye.\\

\normalsize
\end{frame}

\begin{frame}{Пример: FTP}
Информационное соединение №1:\\
\medskip
\scriptsize
{\bfseries telnet ftp.mgts.by 12108}\\
\begin{verbatim}
-rw-r----r----    1 0    0       0 Apr 19  2010 2ban\_me.html\\
-rw-r----r----    1 0    0       197 Jan 27  2010 README\\
lrwxrwxrwx    1 0    0       18 Jan 27  2010 backports.org -> pub/backports.org/\\
drwxr-xr-x    2 0    0       23 May 20  2010 blog\\
drwxr-xr-x   10 0    0       4096 Feb 07 08:48 byfly\\
\end{verbatim}
\normalsize
\end{frame}

\begin{frame}{Пример: FTP}
Информационное соединение №2:\\
\medskip
\scriptsize
{\bfseries telnet ftp.mgts.by 48940}\\
\begin{verbatim}
Welcome to ByFly public archive (ftp.byfly.by)\\
	located at MGTS,  Minsk,  Belarus\\
	sponsored by Beltelecom (www.beltelecom.by)\\
	2 x Intel(R) Xeon(R) CPU X3210  @ 2.13GHz\\
	8 Gb RAM,  6 TB SATA Storage\\
\end{verbatim}
\normalsize
\end{frame}

\section{Проектирование прикладных протоколов}

\begin{frame}{RFC 3117}

	\Huge
	\begin{center}
	Проектирование прикладных протоколов\\
	\end{center}
	\normalsize
	\bigskip
	Disclaimer: основано на \sout{реальных событиях} опыте проектирования протокола Blocks eXtensible eXchange Protocol (BXXP).
\end{frame}

\begin{frame}{Возможные пути при проектировании протокола прикладного уровня}

	\begin{enumerate}
		\item Попытайтесь найти существующий протокол,  который более или менее подходит для ваших нужд.
			\pause
		\item Определите модель для обмена данными поверх инфраструктуры WWW,  если более или менее подходит для ваших нужд.
			\pause
		\item Определите модель для обмена данными поверх инфраструктуры электронной почты,  если она более или менее подходит для ваших нужд.
			\pause
		\item Разработать свой собственный протокол с 0.
	\end{enumerate}
\end{frame}

\begin{frame}{Определение свойств проектируемого протокола}

	\begin{enumerate}
		\item Является ли протокол ориентированным на соединения?
			\pause
		\item Нужно ли использовать запросы и ответы для обмена сообщениями?
			\pause
		\item Нужна ли возможность обмена асинхронными сообщениями?
	\end{enumerate}
\end{frame}

\begin{frame}{Ориентация на соединения}

	\begin{itemize}
		\item Прикладной протокол ориентирован на соединения ( т.е. работает поверх TCP или SCTP)
		\item Без установления соединения -- к ним относятся прикладные протоколы,  для которых нет нужды в задержках на установление/разрыв соединений,  а также поддержке надежной передачи данных.\\
			При необходимости надежность реализуется средствами прикладного протокола.
	\end{itemize}
\end{frame}


\begin{frame}{Обмен сообщениями}

	Под сообщением подразумевается простая структура данных,  которыми обмениваются слабо-связные системы.

	В качестве противовеса можно привести сильно-связные системы,  например RPC.

	Проблема в том,  что слабо- и сильно-связные системы -- граничные части целого спектра.
\end{frame}

\begin{frame}{Асинхронный обмен}

	\begin{block}{Синхронная peer-to-peer модель}
		Модель в стиле <<запрос-ответ>>,  где каждая из сторон может являться клиентом и/или сервером.\\
	Большинство протоколов являются синхронными: почта,  WWW и т. п.
	\end{block}

	Часть протоколов не может быть построена по синхронным принципам — например: сетевые файловые системы,  системы именования,  мультикаст-сообщения и т.п.
\end{frame}

\begin{frame}{Механизмы протокола}

	\begin{block}{Как и какие задачи выполняет протокол?}
	\begin{itemize}
		\item Структурирование -- заголовки,  концевики.
			\pause
		\item Кодирование -- представление.
			\pause
		\item Отчетность -- каким образом описываются ошибки.
			\pause
		\item Асинхронность -- как производится обмен независимыми сообщениями.
			\pause
		\item Аутентификация -- каким образом стороны идентифицируют и проверяют друг друга.
			\pause
		\item Конфиденциальность -- защита от перехвата или измения данных.
	\end{itemize}
	\end{block}
\end{frame}


\begin{frame}{Структурирование (Framing)}

	\begin{block}{Octet-stuffing}
Например SMTP -- команды заканчиваются переводом каретки (CR-LF)
	\end{block}
	\pause
	\begin{block}{Octet-counting}
Сообщение разделяется на заголовок и тело; в заголовке указывается размер данных в теле сообщения.
	\end{block}
	\pause
	\begin{block}{Connection-blasting}
Например информационное соединение FTP.
	\end{block}

\end{frame}
\begin{frame}{Кодирование (Encoding)}

	\large{Зависит от задачи!}

	Под кодированием подразумевается формат представления команд и данных.

	Например для SMTP он определяется в RFC 822.

	В Интернете MIME является <<де-факто>> стандартом представления данных.
\end{frame}

\begin{frame}{Отчетность (Reporting)}

	\begin{block}{<<Теория ответных кодов>>}

	Состоит из 3-х цифр:
	\begin{enumerate}
		\item Успех-неуспех,  либо постоянное или временное состояние; 
		\item ответственная часть системы;
		\item идентификация конкретной ситуации.
	\end{enumerate}
	\end{block}

	Код может дополняться текстовым сообщением для человека.
\end{frame}

\begin{frame}{Отчетность (Reporting)}

	<<Теория ответных кодов>> имеет 2 нерешенных недостатка:
	\begin{itemize}
		\item коды используются как для ответа на операцию,  так и для индикации изменения состояния прикладного протокола;
		\item код не указывает,  кому адресуется ошибка -- пользователю,  администратору или программисту.
	\end{itemize}
\end{frame}

\begin{frame}{Асинхронность (Asynchrony)}

	Протокол является асинхронным,  если он поддерживает независимые обмены по одному соединению. \\
	\bigskip
	Наиболее широко распространенный подход -- pipelining,  позволяет делать множество запросов к серверу,  но требует,  чтобы запросы были обслужены последовательно.
\end{frame}

\begin{frame}{Аутентификация (Authentication)}

	\large{Механизмы специфичны для каждого протокола.}

	Например,  FTP использует один механизм,  HTTP -- другой,  а SMTP (классический) не использует его вовсе.\\
	\bigskip
	Рекомендуется к использованию SASL {\color{gray} (RFC 222 -- Simple Authentication and Security Layer)} -- фреймворк для аутентификации сторон,  использующий в том числе OTP (one-time-passwords).
\end{frame}

\begin{frame}{Конфиденциальность (Privacy)}

	Как правило, подразумевается использование криптографических средств для шифрования данных.\\
	\bigskip
	Наиболее часто используемый механизм -- TLS/SSL -- использует шифрование соединения,  а не отдельных объектов.
\end{frame}

\begin{frame}{Конфиденциальность (Privacy)}

	Можно использовать различные подходы для организации:
	\begin{itemize}
		\item прослушивать на одном порту незащищенные соединения,  а на другом -- защищенные (SSL);
		\item прослушивать и защищенные,  и незащищенные соединения на одном и том же порту,  что требует поддержки со стороны протокола прикладного уровня (TLS).
	\end{itemize}
\end{frame}

\begin{frame}{Примеры протоколов}

	\scriptsize
	\begin{table}[ht]
	\centering
	\begin{tabular}[c]{l|c|c|c}
Механизм & ESMTP & FTP & HTTP 1.1\\
	\hline
Структурирование & stuffing & blasting & counting\\
Представление & RFC 822 & бинарное & MIME\\
Отчетность & 3 цифры & 3 цифры & 3 цифры\\
Асинхронность & pipelining & нет & pipelining и chunking\\
Аутентификация & SASL & user/pass & user/pass\\
Конфиденциальность & SASL или TLS & нет & TLS (SSL)\\
	\end{tabular}
	\end{table}
\end{frame}

\begin{frame}{Свойства протокола}

	При проектировании протокола необходимо учитывать некоторые свойства:
	\begin{enumerate}
		\item Масштабируемость
		\item Эффективность
		\item Простоту
		\item Расширяемость
		\item Устойчивость
	\end{enumerate}
\end{frame}

\begin{frame}{Масштабируемость (Scalability)}

	Хорошо спроектированный протокол должен быть масштабируемым.\\
	\bigskip
	Не все протоколы поддерживают асинхронность.

	Частая практика -- использовать несколько соединений для утилизации канала,  однако при этом необходимо учитывать:
	\begin{itemize}
		\item свойства транспортного протокола;
		\item сервер трактует каждое новое соединение по протоколу прикладного уровня,  как независимое (проблема аутентификации и доступа к ресурсам сессии). 
	\end{itemize}
\end{frame}

\begin{frame}{Эффективность (Efficiency)}

	Хорошо спроектированный протокол должен быть эффективным.\\
	\bigskip

	Например,  использование octet-staffing'а упрощает реализацию протокола,  в то время,  как octet-counting потребляет немного меньше ресурсов.
\end{frame}


\begin{frame}{Простота (Simplicity)}

	Хорошо спроектированный протокол должен быть простым.\\
	\bigskip

	Хорошее правило для определения насколько протокол прост:
	\begin{itemize}
		\item в хорошо спроектированном протоколе усилия для изменения пропорциональны сложности изменений;
		\item в плохо спроектированном протоколе необходимо приложить много усилий для любых изменений.
	\end{itemize}
\end{frame}

\begin{frame}{Расширяемость (Extensibility)}

	Хорошо спроектированный протокол должен быть расширяемым.\\
	\bigskip

	Невозможно предсказать заранее,  с какими проблемами столкнется протокол.

	Таким образом желательно предусмотреть способы расширения функциональности.
\end{frame}

\begin{frame}{Устойчивость (Robustness)}

Хорошо спроектированный протокол должен быть устойчивым.\\
	\bigskip

Внезапно! Но для протоколов принцип устойчивости Постела <<будь либерален к тому,  что принимаешь и консервативен к тому,  что отсылаешь>> может привести к обратному эффекту.\\
	\bigskip

Проблема в количестве и качестве различных реализаций одного и того же протокола.
\end{frame}

\mode<all>{\input{lastpage}}

\end{document}
%Конец файла
